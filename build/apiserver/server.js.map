{"version":3,"sources":["webpack:///server.js","webpack:///webpack/bootstrap a5ee6fc2da1e76918a25","webpack:///./src/apiserver/apiserver.js","webpack:///external \"http\"","webpack:///external \"body-parser\"","webpack:///external \"express\"","webpack:///external \"express-session\"","webpack:///external \"morgan\"","webpack:///external \"passport\"","webpack:///./src/apiserver/modules/index.js","webpack:///./src/apiserver/modules/Account/index.js","webpack:///./src/apiserver/modules/Account/routes.js","webpack:///./src/apiserver/modules/Account/controller.js","webpack:///./src/apiserver/modules/Account/model.js","webpack:///external \"mongoose\"","webpack:///./src/apiserver/modules/Account/passwordEncryption.js","webpack:///external \"bcrypt\"","webpack:///external \"crypto\"","webpack:///./src/shared/helpers/idier.js","webpack:///external \"base58\"","webpack:///external \"generate-password\"","webpack:///./src/shared/helpers/appraise.js","webpack:///external \"validator\"","webpack:///external \"owasp-password-strength-test\"","webpack:///./src/apiserver/modules/Authentication/index.js","webpack:///./src/apiserver/modules/Authentication/passportConfigure.js","webpack:///external \"passport-local\"","webpack:///./src/apiserver/modules/Authentication/ensureLoggedIn.js","webpack:///./src/apiserver/modules/Authentication/routes.js","webpack:///./src/apiserver/modules/Recipient/index.js","webpack:///./src/apiserver/modules/Recipient/routes.js","webpack:///./src/apiserver/modules/Recipient/controller.js","webpack:///./src/apiserver/modules/Recipient/model.js","webpack:///./src/apiserver/modules/Post/index.js","webpack:///./src/apiserver/modules/Post/routes.js","webpack:///./src/apiserver/modules/Post/controller.js","webpack:///./src/apiserver/modules/Post/model.js","webpack:///./src/config/environment.js","webpack:///external \"dotenv\"","webpack:///external \"require-environment-variables\"","webpack:///./src/config/mongoConnect.js","webpack:///./src/config/redisConnect.js","webpack:///external \"redis\"","webpack:///external \"connect-redis\""],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_http","_bodyParser","_bodyParser2","_express","_express2","_expressSession","_expressSession2","_morgan","_morgan2","_passport","_passport2","_modules","_mongoConnect","_mongoConnect2","_redisConnect","_redisConnect2","RedisStore","port","process","env","API_SERVER_PORT","app","use","err","req","res","next","headersSent","status","render","json","urlencoded","extended","name","secret","resave","saveUninitialized","store","client","initialize","session","accountRoutes","recipientRoutes","authenticationRoutes","postRoutes","get","send","on","console","log","close","quit","server","Server","listen","error","require","Object","defineProperty","value","_Account","keys","forEach","key","enumerable","_Recipient","_Authentication","_Post","_interopRequireWildcard","newObj","prototype","hasOwnProperty","AccountController","Account","undefined","_routes","_routes2","_model","_model2","_controller","routes","Router","route","post","addAccountEndpoint","ensureLoggedIn","getAccountInfoEndpoint","updateAccountEndpoint","activeAccountId","currentAccount","user","onBehalfOfId","body","length","canActOnBehalfOf","accountId","_req$body","email","password","displayName","newAccount","setPassword","then","save","createdAccount","cleanedAccount","toJSON","success","message","account","catch","code","statusMessage","end","errorMessage","findOneAccount","item","cleanedItem","_mongoose","_mongoose2","_passwordEncryption","_idier","_appraise","AccountType","NORMAL","ADMIN","CUSTSERVICE","BANNED","AccountSchema","Schema","type","Types","Number","unique","required","accountType","String","enum","trim","lowercase","encryptedPasswordHash","encryptedPasswordPepperId","dateCreated","Date","now","dateAccountValidated","dateUpdated","set","transform","doc","objRepresentation","passwordEncryptionPepperId","methods","self","this","Promise","resolve","appraisePassword","appraisalMessages","Error","join","passwordValue","encryptPassword","encryptedValue","dir","encrypted","pepperId","pre","idier","done","errorMessages","emailAppraisal","appraiseEmail","invalidate","push","displayNameAppraisal","appraiseDisplayName","comparePassword","candidate","passwordsMatch","statics","findOne","exec","findOneByEmail","model","aesHash","bcryptHash","hashPassword","deAesHash","_bcrypt","_crypto","_crypto2","hasher","createHash","update","hashed","digest","passwordhash","saltRounds","hash","currentPepperId","ACCOUNT_ENCRYPT_CURRENT_PEPPER","pepper","algorithm","cipher","createCipher","crypted","final","rawPassword","decipher","createDecipher","decrypted","candidatePassword","candidateHashed","decryptedPass","compare","passGen","toNumericId","toHumanId","_base","_base2","_generatePassword","_generatePassword2","mySequence","globalSeq","global","idierSequence","workerId","IDIER_WORKER_ID","Math","floor","random","timeStamp","randomnumber","snowflake","snowflakeInt","parseInt","idNumber","encoded","encode","idString","decoded","decode","generate","numbers","appraisePostMessage","appraisePostSubject","appraiseAccountId","appraisePasswordErrors","appraisePasswordExtra","appraiseThese","_validator","_owaspPasswordStrengthTest","_owaspPasswordStrengthTest2","emailAddress","messages","isEmpty","isEmail","owaspResults","test","strong","concat","errors","minLength","maxLength","repeating","needLowercase","needUppercase","needNumber","needCharacter","what","appraised","tested","postMessage","postSubject","_ensureLoggedIn","_ensureLoggedIn2","_passportLocal","Strategy","usernameField","passwordField","callback","foundAccount","theAccount","passwordsMatched","accountToReturn","serializeUser","deserializeUser","options","unauthenticatedRedirectURL","redirectTo","allOptions","setReturnTo","isAuthenticated","returnTo","originalUrl","url","redirect","signinUser","authenticate","logIn","cookie","httpOnly","delete","destroy","logout","clearCookie","RecipientController","Recipient","getRecipientsEndpoint","addRecipientEndpoint","put","updateRecipientEndpoint","removeRecipientEndpoint","findAllForId","recipients","cleanRecipients","map","recipient","newRecipient","ownerAccountId","createdRecipient","toObject","recipientId","params","_req$body2","updates","updatedRecipient","RecipientStatus","REMOVED","VALIDATING","ACTIVE","BOUNCING","UNSUBSCRIBED","RecipientSchema","index","phoneNumber","phoneType","dateRecipientValidated","dateUnsubscribed","unsubscriptionReason","dateRemoved","findOneRecipient","ownerId","fieldsToUpdate","foundItem","foundRecipient","fieldsToUpdateKeys","lean","arguments","find","totalForAccountId","count","PostController","Post","getPostsEndpoint","addPostEndpoint","updatePostEndpoint","removePostEndpoint","items","cleanedItems","mappedItem","posts","subject","mediaIds","newItem","createdItem","cleanedPost","itemId","postId","updatedItem","PostStatus","MAX_RETURN_LIMIT","DRAFT","POSTED","PostSchema","Array","findOnePost","foundPost","limit","beforeId","limiter","$lte","sort","_dotenv","_dotenv2","_requireEnvironmentVariables","_requireEnvironmentVariables2","NODE_ENV","load","MONGODB_URI","socketOptions","keepAlive","connectTimeoutMS","replset","connect","connection","once","warn","_redis","_redis2","REDIS_URL","redisClient","createClient"],"mappings":"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","file":"server.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _http = __webpack_require__(1);\n\t\n\tvar _bodyParser = __webpack_require__(2);\n\t\n\tvar _bodyParser2 = _interopRequireDefault(_bodyParser);\n\t\n\tvar _express = __webpack_require__(3);\n\t\n\tvar _express2 = _interopRequireDefault(_express);\n\t\n\tvar _expressSession = __webpack_require__(4);\n\t\n\tvar _expressSession2 = _interopRequireDefault(_expressSession);\n\t\n\tvar _morgan = __webpack_require__(5);\n\t\n\tvar _morgan2 = _interopRequireDefault(_morgan);\n\t\n\tvar _passport = __webpack_require__(6);\n\t\n\tvar _passport2 = _interopRequireDefault(_passport);\n\t\n\tvar _modules = __webpack_require__(7);\n\t\n\t__webpack_require__(35);\n\t\n\tvar _mongoConnect = __webpack_require__(38);\n\t\n\tvar _mongoConnect2 = _interopRequireDefault(_mongoConnect);\n\t\n\tvar _redisConnect = __webpack_require__(39);\n\t\n\tvar _redisConnect2 = _interopRequireDefault(_redisConnect);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* Routes */\n\t/* Base imports */\n\tvar RedisStore = __webpack_require__(41)(_expressSession2.default);\n\t/* Configurations */\n\t\n\t\n\tvar port = process.env.API_SERVER_PORT;\n\tif (!port) {\n\t  port = 3006;\n\t}\n\t\n\tvar app = (0, _express2.default)();\n\t\n\t/* Middleware setup */\n\tapp.use(function (err, req, res, next) {\n\t  if (res.headersSent) next(err);\n\t  res.status(err.status || port).render('500');\n\t});\n\tapp.use(_bodyParser2.default.json());\n\tapp.use(_bodyParser2.default.urlencoded({ extended: true }));\n\tapp.use((0, _expressSession2.default)({\n\t  name: 'snss',\n\t  secret: 'MmyWTLNNsTi15LYHz8FP',\n\t  resave: true,\n\t  saveUninitialized: false,\n\t  store: new RedisStore({ client: _redisConnect2.default })\n\t}));\n\tapp.use(_passport2.default.initialize());\n\tapp.use(_passport2.default.session());\n\tapp.use((0, _morgan2.default)('combined'));\n\t\n\t/* Routes */\n\tapp.use('/api/v1', [_modules.accountRoutes, _modules.recipientRoutes, _modules.authenticationRoutes, _modules.postRoutes]);\n\t\n\tapp.get('/', function baseReturn(req, res) {\n\t  res.send('Hello - this is the api server. You probably want a more interesting endpoint.');\n\t});\n\t\n\tprocess.on('SIGTERM', function () {\n\t  console.log('Closing server.');\n\t  app.close();\n\t});\n\t\n\tapp.on('close', function () {\n\t  console.log('Closing redis.');\n\t  _redisConnect2.default.quit();\n\t  _mongoConnect2.default.close();\n\t});\n\t\n\t/* Start the API Server */\n\tvar server = (0, _http.Server)(app);\n\tserver.listen(port, function reportOnListen(error) {\n\t  if (error) {\n\t    console.log('API Server ERROR on startup: ' + error);\n\t  } else {\n\t    console.log('API Server listening on http://localhost:' + port + '.');\n\t  }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"http\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"body-parser\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"express\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"express-session\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"morgan\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"passport\");\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Account = __webpack_require__(8);\n\t\n\tObject.keys(_Account).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Account[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Recipient = __webpack_require__(27);\n\t\n\tObject.keys(_Recipient).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Recipient[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Authentication = __webpack_require__(22);\n\t\n\tObject.keys(_Authentication).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Authentication[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Post = __webpack_require__(31);\n\t\n\tObject.keys(_Post).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Post[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.AccountController = exports.Account = exports.accountRoutes = undefined;\n\t\n\tvar _routes = __webpack_require__(9);\n\t\n\tvar _routes2 = _interopRequireDefault(_routes);\n\t\n\tvar _model = __webpack_require__(11);\n\t\n\tvar _model2 = _interopRequireDefault(_model);\n\t\n\tvar _controller = __webpack_require__(10);\n\t\n\tvar AccountController = _interopRequireWildcard(_controller);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.accountRoutes = _routes2.default;\n\texports.Account = _model2.default;\n\texports.AccountController = AccountController;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _express = __webpack_require__(3);\n\t\n\tvar _controller = __webpack_require__(10);\n\t\n\tvar _Authentication = __webpack_require__(22);\n\t\n\tvar routes = new _express.Router();\n\t\n\troutes.route('/account').post(_controller.addAccountEndpoint);\n\t\n\troutes.get('/account', (0, _Authentication.ensureLoggedIn)(), _controller.getAccountInfoEndpoint);\n\t\n\texports.default = routes;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getAccountInfoEndpoint = exports.updateAccountEndpoint = exports.addAccountEndpoint = undefined;\n\t\n\tvar _model = __webpack_require__(11);\n\t\n\tvar _model2 = _interopRequireDefault(_model);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* Returns either the current account's accountId or, if onBehalfOfId is passed in\n\t *  to the body, it will verify if the current account can act on behalf of the passed\n\t *  in id and return that.\n\t *  @param {object} req - the request object that has a user account attached\n\t *  @returns {string} accountId - the accountId to use in searches.\n\t *   TODO: need to move it to it's own module since we're duplicating it in every controller.\n\t */\n\tvar activeAccountId = function getAccount(req) {\n\t  var currentAccount = req.user;\n\t  var onBehalfOfId = req.body.onBehalfOfId;\n\t  if (onBehalfOfId && onBehalfOfId.length > 0) {\n\t    if (currentAccount && currentAccount.canActOnBehalfOf(onBehalfOfId)) {\n\t      return onBehalfOfId;\n\t    }\n\t  }\n\t  if (req.user && req.user.accountId) {\n\t    return req.user.accountId;\n\t  }\n\t  return null;\n\t};\n\t\n\t/* Adds an account to the Accounts database based on the fields passed in.\n\t * Params needed in body:\n\t *   @param {string} email - the email address\n\t *   @param {string} password - the user's password. Must pass owasp tests.\n\t *   @param {string} displayName - the name to display on the users page.\n\t */\n\tvar addAccountEndpoint = function addAccountEndpoint(req, res) {\n\t  var _req$body = req.body,\n\t      email = _req$body.email,\n\t      password = _req$body.password,\n\t      displayName = _req$body.displayName;\n\t\n\t  var newAccount = new _model2.default({ email: email, password: password, displayName: displayName });\n\t  newAccount.setPassword(password).then(function () {\n\t    // eslint-disable-line arrow-body-style\n\t    return newAccount.save();\n\t  }).then(function (createdAccount) {\n\t    var cleanedAccount = createdAccount.toJSON();\n\t    res.status(201).json({\n\t      success: true,\n\t      message: 'Successfully Registered',\n\t      account: cleanedAccount\n\t    });\n\t  }).catch(function (err) {\n\t    if (err.code === 11000) {\n\t      res.statusMessage = 'Account with that email already exists'; // eslint-disable-line no-param-reassign\n\t      res.status(409).end();\n\t      return;\n\t    }\n\t    var errorMessage = 'Account could not be created.';\n\t    if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  });\n\t};\n\t\n\t/* Get account info for accountId.\n\t * Params needed in req.body:\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the search parameters.\n\t */\n\tvar getAccountInfoEndpoint = function getAccountInfoEndpoint(req, res) {\n\t  // eslint-disable-line consistent-return\n\t  var accountId = activeAccountId(req);\n\t  if (!accountId) {\n\t    return res.status(422).json({ success: false, message: 'No accountId provided' });\n\t  }\n\t  _model2.default.findOneAccount(accountId, false).then(function (item) {\n\t    var cleanedItem = item.toJSON();\n\t    res.status(201).json({\n\t      success: true,\n\t      account: cleanedItem\n\t    });\n\t  }).catch(function (err) {\n\t    res.statusMessage = err.message; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  });\n\t};\n\t\n\tvar updateAccountEndpoint = function updateAccountEndpoint(req, res) {\n\t  res.status(418).json({\n\t    message: 'Brewing'\n\t  });\n\t};\n\t\n\texports.addAccountEndpoint = addAccountEndpoint;\n\texports.updateAccountEndpoint = updateAccountEndpoint;\n\texports.getAccountInfoEndpoint = getAccountInfoEndpoint;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _mongoose = __webpack_require__(12);\n\t\n\tvar _mongoose2 = _interopRequireDefault(_mongoose);\n\t\n\tvar _passwordEncryption = __webpack_require__(13);\n\t\n\tvar _idier = __webpack_require__(16);\n\t\n\tvar _appraise = __webpack_require__(19);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* The various states an account can be in. Used in the schema for account.accountType.\n\t */\n\tvar AccountType = {\n\t  NORMAL: 'normal',\n\t  ADMIN: 'admin',\n\t  CUSTSERVICE: 'custservice',\n\t  BANNED: 'banned'\n\t};\n\t\n\t/* Account schema represents all accounts.\n\t * Note: We are not using the pepperId yet, there's only one pepper\n\t */\n\tvar AccountSchema = new _mongoose.Schema({\n\t  accountId: {\n\t    type: _mongoose.Schema.Types.Number,\n\t    unique: true,\n\t    required: true\n\t  },\n\t  accountType: {\n\t    type: String,\n\t    enum: [AccountType.NORMAL, AccountType.ADMIN, AccountType.CUSTSERVICE, AccountType.BANNED],\n\t    default: AccountType.NORMAL\n\t  },\n\t  email: {\n\t    type: String,\n\t    trim: true,\n\t    unique: true,\n\t    lowercase: true\n\t  },\n\t  displayName: {\n\t    type: String,\n\t    trim: true\n\t  },\n\t  encryptedPasswordHash: {\n\t    type: String,\n\t    trim: true,\n\t    required: true\n\t  },\n\t  encryptedPasswordPepperId: {\n\t    type: String\n\t  },\n\t  dateCreated: {\n\t    type: Date,\n\t    default: Date.now\n\t  },\n\t  dateAccountValidated: {\n\t    type: Date\n\t  },\n\t  dateUpdated: {\n\t    type: Date,\n\t    default: Date.now\n\t  }\n\t});\n\t\n\t/* Remove password and pepper from exported json && object\n\t * Based on: http://ksloan.net/tips-for-using-mongoose-schemas-with-express-mongo-express-node-stack/\n\t */\n\tAccountSchema.set('toJSON', {\n\t  transform: function transformJSON(doc, objRepresentation) {\n\t    delete objRepresentation.encryptedPasswordHash; // eslint-disable-line no-param-reassign\n\t    delete objRepresentation.passwordEncryptionPepperId; // eslint-disable-line no-param-reassign\n\t    return objRepresentation;\n\t  }\n\t});\n\t\n\tAccountSchema.set('toJSON', {\n\t  transform: function transformJSON(doc, objRepresentation) {\n\t    return {\n\t      displayName: objRepresentation.displayName,\n\t      email: objRepresentation.email,\n\t      dateCreated: objRepresentation.dateCreated,\n\t      dateAccountValidated: objRepresentation.dateAccountValidated,\n\t      dateUpdated: objRepresentation.dateUpdated,\n\t      accountId: objRepresentation.accountId,\n\t      accountType: objRepresentation.accountType\n\t    };\n\t  }\n\t});\n\t\n\tAccountSchema.set('toObject', {\n\t  transform: function transformObject(doc, objRepresentation) {\n\t    delete objRepresentation.encryptedPasswordHash; // eslint-disable-line no-param-reassign\n\t    delete objRepresentation.passwordEncryptionPepperId; // eslint-disable-line no-param-reassign\n\t    return objRepresentation;\n\t  }\n\t});\n\t\n\t/* Sets the account password (technically, encryptedPasswordHash)\n\t * Sends the password through hashing and encryption and saves it the the database.\n\t * returns {Promise}\n\t */\n\tAccountSchema.methods.setPassword = function setPassword(password) {\n\t  var self = this;\n\t\n\t  return Promise.resolve((0, _appraise.appraisePassword)(password)).then(function checkAppraisal(appraisalMessages) {\n\t    if (appraisalMessages.length > 0) {\n\t      throw new Error(appraisalMessages.join(', '));\n\t    }\n\t    return password;\n\t  }).then(function runHashing(passwordValue) {\n\t    return (0, _passwordEncryption.encryptPassword)(passwordValue);\n\t  }).then(function (encryptedValue) {\n\t    console.log('Got encrypted value: ');\n\t    console.dir(encryptedValue);\n\t    self.encryptedPasswordHash = encryptedValue.encrypted;\n\t    self.encryptedPasswordPepperId = encryptedValue.pepperId;\n\t  }).catch(function (err) {\n\t    throw err;\n\t  });\n\t};\n\t\n\t/* If we don't have an accountID (say, on a new account), set one. */\n\tAccountSchema.pre('validate', function preValidateAddAccountId(next) {\n\t  if (!this.accountId) {\n\t    this.accountId = (0, _idier.idier)();\n\t  }\n\t  next();\n\t});\n\t\n\t/* Update the dateUpdated field on save. */\n\tAccountSchema.pre('save', true, function updateDate(next, done) {\n\t  this.dateUpdated = new Date();\n\t  next();\n\t  done();\n\t});\n\t\n\t/* Does the pre-save validations.\n\t * Why here instead of on each individual field? Allows us to return multiple errors at once.\n\t */\n\tAccountSchema.pre('save', true, function preSaveValidations(next, done) {\n\t  var errorMessages = [];\n\t  var emailAppraisal = (0, _appraise.appraiseEmail)(this.email);\n\t  if (emailAppraisal.length > 0) {\n\t    this.invalidate('email', emailAppraisal.join(', '));\n\t    errorMessages.push(emailAppraisal.join(', '));\n\t  }\n\t\n\t  var displayNameAppraisal = (0, _appraise.appraiseDisplayName)(this.displayName);\n\t  if (displayNameAppraisal.length > 0) {\n\t    this.invalidate('displayName', displayNameAppraisal.join(', '));\n\t    errorMessages.push(displayNameAppraisal.join(' '));\n\t  }\n\t  if (errorMessages.length > 0) {\n\t    done(new Error(errorMessages.join(' ')));\n\t  }\n\t  next();\n\t  done();\n\t});\n\t\n\tAccountSchema.methods.comparePassword = function comparePassword(candidate) {\n\t  return (0, _passwordEncryption.passwordsMatch)(candidate, this.encryptedPasswordHash, this.encryptedPasswordPepperId);\n\t};\n\t\n\t/* Can this account act on behalf of another account?\n\t * @param {number} *ignored* the Account id to check against.\n\t * @returns {bool} true if account can act on behalf of accountId\n\t * @note Currently, only checks if this account has an account type of admin or customer service\n\t*/\n\tAccountSchema.methods.canActOnBehalfOf = function canActOnBehalfOf(accountId) {\n\t  // eslint-disable-line\n\t  if (this.accountType === AccountType.ADMIN || this.accountType === AccountType.CUSTSERVICE) {\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\t\n\t/* Find an account by an accountId\n\t * @param {number} accountId - the account id\n\t * @returns {promise} - a promise to find something\n\t */\n\tAccountSchema.statics.findOneAccount = function findAccountById(accountId) {\n\t  return this.findOne({ accountId: accountId }).exec();\n\t};\n\t\n\t/* Find an account by an email address\n\t * @param {string} email - the associated email address\n\t * @returns {promise} - a promise to find something\n\t */\n\tAccountSchema.statics.findOneByEmail = function findAccountByEmail(email) {\n\t  return this.findOne({ email: email }).exec();\n\t};\n\t\n\t/* Compile the schema into a model\n\t * http://mongoosejs.com/docs/models.html\n\t */\n\tvar Account = _mongoose2.default.model('Account', AccountSchema);\n\t\n\texports.default = Account;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"mongoose\");\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.passwordsMatch = exports.aesHash = exports.bcryptHash = exports.hashPassword = exports.deAesHash = exports.encryptPassword = undefined;\n\t\n\tvar _bcrypt = __webpack_require__(14);\n\t\n\tvar _crypto = __webpack_require__(15);\n\t\n\tvar _crypto2 = _interopRequireDefault(_crypto);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* Hashes the password into a SHA512 hex hash */\n\tvar hashPassword = function hashPassword(password) {\n\t  var hasher = _crypto2.default.createHash('sha512');\n\t  hasher.update(password);\n\t  var hashed = hasher.digest('hex');\n\t  return hashed;\n\t};\n\t\n\t/* Bcrypts a string (expects a hash) with 10 rounds and a per user salt\n\t * Salt is returned as part of the hash and thus saved.\n\t * Note that this version of bcrypt only takes the first 72 characters.\n\t  */\n\tvar bcryptHash = function bcryptHash(passwordhash) {\n\t  var saltRounds = 10;\n\t  return (0, _bcrypt.hash)(passwordhash, saltRounds);\n\t};\n\t\n\t/* Encrypts the bcrypted string using aes256 using a pepper stored\n\t *   in the environment. This is what should be finally saved.\n\t */\n\tvar aesHash = function aesHash(passwordhash) {\n\t  var currentPepperId = process.env.ACCOUNT_ENCRYPT_CURRENT_PEPPER;\n\t  var pepper = process.env[currentPepperId];\n\t  var algorithm = 'aes-256-ctr';\n\t  var cipher = _crypto2.default.createCipher(algorithm, pepper);\n\t  var crypted = cipher.update(passwordhash, 'utf8', 'hex');\n\t  crypted += cipher.final('hex');\n\t  return { encrypted: crypted, pepperId: currentPepperId };\n\t};\n\t\n\t/* Encrypting a password.\n\t   Follows dropbox's pattern of hashing, bcrypting, then encrypting.\n\t   Seems safer: https://blogs.dropbox.com/tech/2016/09/how-dropbox-securely-stores-your-passwords/\n\t*/\n\tvar encryptPassword = function encryptPassword(rawPassword) {\n\t  return Promise.resolve(rawPassword).then(hashPassword).then(bcryptHash).then(aesHash);\n\t};\n\t\n\t/* Decrypts the encrypted bcrypt hash using aes256 using a pepper stored\n\t *   in the environment. Should use this only with the bcrypted, hashed password.\n\t */\n\tvar deAesHash = function deAesHash(passwordhash, pepperId) {\n\t  var pepper = process.env[pepperId];\n\t  if (!pepper) {\n\t    return new Error('Pepper not found.');\n\t  }\n\t  var algorithm = 'aes-256-ctr';\n\t  var decipher = _crypto2.default.createDecipher(algorithm, pepper);\n\t  var decrypted = decipher.update(passwordhash, 'hex', 'utf8');\n\t  decrypted += decipher.final('utf8');\n\t  return decrypted;\n\t};\n\t\n\t/* Compare passwords.\n\t * Because we are using hashing and encrypting, we have to do that before we compare.\n\t */\n\tvar passwordsMatch = function passwordsMatch(candidatePassword, encryptedPasswordHash, pepperId) {\n\t  // compare the submitted password to encrypted password in database.\n\t  var candidateHashed = hashPassword(candidatePassword);\n\t  var decryptedPass = deAesHash(encryptedPasswordHash, pepperId);\n\t  return (0, _bcrypt.compare)(candidateHashed, decryptedPass);\n\t};\n\t\n\texports.encryptPassword = encryptPassword;\n\texports.deAesHash = deAesHash;\n\texports.hashPassword = hashPassword;\n\texports.bcryptHash = bcryptHash;\n\texports.aesHash = aesHash;\n\texports.passwordsMatch = passwordsMatch;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"bcrypt\");\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"crypto\");\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.passGen = exports.toNumericId = exports.toHumanId = exports.idier = undefined;\n\t\n\tvar _base = __webpack_require__(17);\n\t\n\tvar _base2 = _interopRequireDefault(_base);\n\t\n\tvar _generatePassword = __webpack_require__(18);\n\t\n\tvar _generatePassword2 = _interopRequireDefault(_generatePassword);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* idier: identifier generator. Inspired by twitter's snowflake system\n\t * https://blog.twitter.com/2010/announcing-snowflake\n\t * We use the timestamp converted to seconds + a worker id from the environment +\n\t *   a sequence number (see below) + a single random number just in case...\n\t */\n\tvar idier = function idier() {\n\t  /* The sequence is stored on the global object. The sequence should be between 1-999 to keep\n\t   *   our total id number in the right space to be converted.\n\t   *   Note: There's probably an opportunity to use Redis or similar for the sequence.\n\t   */\n\t  var mySequence = 1;\n\t  var globalSeq = global.idierSequence;\n\t  if (globalSeq && globalSeq < 1000 && globalSeq > 0) {\n\t    mySequence = globalSeq;\n\t    global.idierSequence += 1;\n\t  } else {\n\t    global.idierSequence = mySequence + 1;\n\t  }\n\t\n\t  var workerId = process.env.IDIER_WORKER_ID;\n\t  if (!workerId) {\n\t    workerId = Math.floor(Math.random() * 10);\n\t  }\n\t  var timeStamp = Math.floor(Date.now() / 1000);\n\t  var randomnumber = Math.floor(Math.random() * 10);\n\t  var snowflake = '' + timeStamp + workerId + mySequence + randomnumber;\n\t  var snowflakeInt = parseInt(snowflake, 10);\n\t  return snowflakeInt;\n\t};\n\t\n\t/* toHumanId - transform a number into a base58 encoded string for use in human visible tokens.\n\t   Uses https://www.npmjs.com/package/base58\n\t  */\n\tvar toHumanId = function toHumanId(idNumber) {\n\t  var encoded = _base2.default.encode(idNumber);\n\t  return encoded;\n\t};\n\t\n\t/* toNumbericId - transform a humanId (base32 encoded) string to a number to use by the computer.\n\t  */\n\tvar toNumericId = function toNumericId(idString) {\n\t  var decoded = _base2.default.decode(idString);\n\t  return decoded;\n\t};\n\t\n\t/* Password generator\n\t * Creates a 12 digit password with letters and numbers.\n\t*/\n\tvar passGen = function passGen() {\n\t  var password = _generatePassword2.default.generate({\n\t    length: 12,\n\t    numbers: true\n\t  });\n\t  return password;\n\t};\n\t\n\texports.idier = idier;\n\texports.toHumanId = toHumanId;\n\texports.toNumericId = toNumericId;\n\texports.passGen = passGen;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"base58\");\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"generate-password\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.appraisePostMessage = exports.appraisePostSubject = exports.appraiseAccountId = exports.appraisePasswordErrors = exports.appraisePasswordExtra = exports.appraisePassword = exports.appraiseDisplayName = exports.appraiseEmail = exports.appraiseThese = undefined;\n\t\n\tvar _validator = __webpack_require__(20);\n\t\n\tvar _owaspPasswordStrengthTest = __webpack_require__(21);\n\t\n\tvar _owaspPasswordStrengthTest2 = _interopRequireDefault(_owaspPasswordStrengthTest);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* Is the email valid? Uses the validator library to test.\n\t */\n\tvar appraiseEmail = function appraiseEmail(emailAddress) {\n\t  var messages = [];\n\t  if ((0, _validator.isEmpty)(emailAddress)) {\n\t    messages.push('Email address is required.');\n\t  }\n\t  if (!(0, _validator.isEmpty)(emailAddress) && !(0, _validator.isEmail)(emailAddress)) {\n\t    messages.push('Email address does not appear to be valid.');\n\t  }\n\t  return messages;\n\t};\n\t\n\t/* Test for the validity of the displayName.\n\t *  Currently only checks if it's empty.\n\t */\n\tvar appraiseDisplayName = function appraiseDisplayName(displayName) {\n\t  var messages = [];\n\t  if ((0, _validator.isEmpty)(displayName)) {\n\t    messages.push('Display name is required.');\n\t  }\n\t  return messages;\n\t};\n\t\n\t/* Tests a password.\n\t * Must be valid and pass the owasp validation tests.\n\t */\n\tvar appraisePassword = function appraisePassword(password) {\n\t  var messages = [];\n\t  if ((0, _validator.isEmpty)(password)) {\n\t    messages.push('Password is required.');\n\t  } else {\n\t    var owaspResults = _owaspPasswordStrengthTest2.default.test(password);\n\t    if (!owaspResults.strong) {\n\t      messages = messages.concat(owaspResults.errors);\n\t    }\n\t  }\n\t  return messages;\n\t};\n\t\n\tvar appraisePasswordErrors = {\n\t  minLength: 0,\n\t  maxLength: 1,\n\t  repeating: 2,\n\t  needLowercase: 3,\n\t  needUppercase: 4,\n\t  needNumber: 5,\n\t  needCharacter: 6\n\t};\n\t\n\t/* A wrapper for awasp tests that returns this\n\t * {\n\t *   errors              : [],\n\t *   failedTests         : [],\n\t *   requiredTestErrors  : [],\n\t *   optionalTestErrors  : [],\n\t *   passedTests         : [ 0, 1, 2, 3, 4, 5, 6 ],\n\t *   isPassphrase        : false,\n\t *   strong              : true,\n\t *   optionalTestsPassed : 4\n\t * }\n\t */\n\tvar appraisePasswordExtra = function appraisePasswordExtra(password) {\n\t  return _owaspPasswordStrengthTest2.default.test(password);\n\t};\n\t\n\t/* Tests for the presense of an accountID.\n\t *  Only checks if it's empty.\n\t *  TODO: Check if the account actually exists.\n\t */\n\tvar appraiseAccountId = function appraiseAccountId(accountId) {\n\t  var messages = [];\n\t  if ((0, _validator.isEmpty)(accountId)) {\n\t    messages.push('AccountId is required.');\n\t  }\n\t  return messages;\n\t};\n\t\n\t/* Validates multiple options. Pass in an object with one of the following:\n\t * email: {string} validates an email (or empty}\n\t * displayName; {string} checks for empty\n\t * password: {string} validates a password\n\t * accountId: {string} validates the accountId\n\t * @returns: an object (see validator object below)\n\t */\n\tvar appraiseThese = function appraiseThese(what) {\n\t  var appraised = {\n\t    success: true, // Did all tests pass\n\t    tested: [], // Which tests where done? Check this to make sure things were passed in correctly.\n\t    errors: {} };\n\t  if ('email' in what) {\n\t    appraised.tested.push('email');\n\t    var messages = appraiseEmail(what.email);\n\t    if (messages && messages.length > 0) {\n\t      appraised.success = false;\n\t      appraised.errors.email = messages;\n\t    }\n\t  }\n\t  if ('password' in what) {\n\t    appraised.tested.push('password');\n\t    var _messages = appraisePassword(what.password);\n\t    if (_messages && _messages.length > 0) {\n\t      appraised.success = false;\n\t      appraised.errors.password = _messages;\n\t    }\n\t  }\n\t  if ('displayName' in what) {\n\t    appraised.tested.push('displayName');\n\t    var _messages2 = appraiseDisplayName(what.displayName);\n\t    if (_messages2 && _messages2.length > 0) {\n\t      appraised.success = false;\n\t      appraised.errors.displayName = _messages2;\n\t    }\n\t  }\n\t  if ('accountId' in what) {\n\t    appraised.tested.push('accountId');\n\t    var _messages3 = appraiseAccountId(what.accountId);\n\t    if (_messages3 && _messages3.length > 0) {\n\t      appraised.success = false;\n\t      appraised.errors.accountId = _messages3;\n\t    }\n\t  }\n\t  return appraised;\n\t};\n\t\n\t/* Tests for the presense of a post message.\n\t *  Only checks if it's empty.\n\t *  Here for future functionality.\n\t */\n\tvar appraisePostMessage = function appraisePostMessage(postMessage) {\n\t  var messages = [];\n\t  if (!postMessage || (0, _validator.isEmpty)(postMessage)) {\n\t    messages.push('A message is required.');\n\t  }\n\t  return messages;\n\t};\n\t\n\t/* Tests for the presense of a post subject.\n\t *  Runs no checks.\n\t *  Here for future functionality.\n\t */\n\t/* eslint-disable no-unused-vars */\n\tvar appraisePostSubject = function appraisePostSubject(postSubject) {\n\t  return [];\n\t};\n\t/* eslint-enable no-unused-vars */\n\t\n\texports.appraiseThese = appraiseThese;\n\texports.appraiseEmail = appraiseEmail;\n\texports.appraiseDisplayName = appraiseDisplayName;\n\texports.appraisePassword = appraisePassword;\n\texports.appraisePasswordExtra = appraisePasswordExtra;\n\texports.appraisePasswordErrors = appraisePasswordErrors;\n\texports.appraiseAccountId = appraiseAccountId;\n\texports.appraisePostSubject = appraisePostSubject;\n\texports.appraisePostMessage = appraisePostMessage;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"validator\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"owasp-password-strength-test\");\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.authenticationRoutes = exports.ensureLoggedIn = undefined;\n\t\n\t__webpack_require__(23);\n\t\n\tvar _ensureLoggedIn = __webpack_require__(25);\n\t\n\tvar _ensureLoggedIn2 = _interopRequireDefault(_ensureLoggedIn);\n\t\n\tvar _routes = __webpack_require__(26);\n\t\n\tvar _routes2 = _interopRequireDefault(_routes);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.ensureLoggedIn = _ensureLoggedIn2.default;\n\texports.authenticationRoutes = _routes2.default;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _passportLocal = __webpack_require__(24);\n\t\n\tvar _passport = __webpack_require__(6);\n\t\n\tvar _passport2 = _interopRequireDefault(_passport);\n\t\n\tvar _model = __webpack_require__(11);\n\t\n\tvar _model2 = _interopRequireDefault(_model);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* Configure the local strategy for use by Passport.\n\t *\n\t * The local strategy require a `verify` function which receives the credentials\n\t * (`username` and `password`) submitted by the user.  The function must verify\n\t * that the password is correct and then invoke `callback` with a user object, which\n\t * will be set at `req.user` in route handlers after authentication.\n\t */\n\t_passport2.default.use(new _passportLocal.Strategy({\n\t  usernameField: 'email',\n\t  passwordField: 'password'\n\t}, function snsLocalStrategy(email, password, callback) {\n\t  var foundAccount = null;\n\t  _model2.default.findOneByEmail(email).then(function comparePass(theAccount) {\n\t    foundAccount = theAccount;\n\t    return theAccount.comparePassword(password);\n\t  }).then(function returnAccount(passwordsMatched) {\n\t    if (!passwordsMatched) {\n\t      throw new Error('Could not verify account');\n\t    }\n\t    return foundAccount;\n\t  }).then(function returnAccount(accountToReturn) {\n\t    callback(null, accountToReturn);\n\t  }).catch(function catchAuthFailure(err) {\n\t    console.log('Passport authentication failed: Unknown error: ' + err);\n\t    return callback(null, false, { message: 'Could not authenticate account' });\n\t  });\n\t}));\n\t\n\t/* Configure Passport authenticated session persistence.\n\t *\n\t * In order to restore authentication state across HTTP requests, Passport needs\n\t * to serialize users into and deserialize users out of the session.  The\n\t * typical implementation of this is as simple as supplying the user ID when\n\t * serializing, and querying the user record by ID from the database when\n\t * deserializing.\n\t */\n\t_passport2.default.serializeUser(function serializeAccount(account, callback) {\n\t  callback(null, account.accountId);\n\t});\n\t\n\t_passport2.default.deserializeUser(function deserializeAccount(accountId, callback) {\n\t  _model2.default.findOneAccount(accountId).then(function determineAction(theAccount) {\n\t    return callback(null, theAccount);\n\t  }).catch(function noFind(err) {\n\t    return callback(err);\n\t  });\n\t});\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"passport-local\");\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = ensureLoggedIn;\n\t/* Based on here: https://github.com/jaredhanson/connect-ensure-login/blob/master/lib/ensureLoggedIn.js\n\t * Used under MIT license\n\t * I edited it to make it go along with my linter and easier for me to understand.\n\t * Original release notes:\n\t * Ensure that a user is logged in before proceeding to next route middleware.\n\t *\n\t * This middleware ensures that a user is logged in.  If a request is received\n\t * that is unauthenticated, the request will be redirected to a login page (by\n\t * default to `/login`).\n\t *\n\t * Additionally, `returnTo` will be be set in the session to the URL of the\n\t * current request.  After authentication, this value can be used to redirect\n\t * the user to the page that was originally requested.\n\t *\n\t * Options:\n\t *   - `redirectTo`   URL to redirect to for login, defaults to _/login_\n\t *   - `setReturnTo`  set redirectTo in session, defaults to _true_\n\t *\n\t * Examples:\n\t *\n\t *     app.get('/profile',\n\t *       ensureLoggedIn(),\n\t *       function(req, res) { ... });\n\t *\n\t *     app.get('/profile',\n\t *       ensureLoggedIn('/signin'),\n\t *       function(req, res) { ... });\n\t *\n\t *     app.get('/profile',\n\t *       ensureLoggedIn({ redirectTo: '/session/new', setReturnTo: false }),\n\t *       function(req, res) { ... });\n\t *\n\t * @param {Object} options\n\t * @return {Function}\n\t * @api public\n\t */\n\tfunction ensureLoggedIn(options) {\n\t  var unauthenticatedRedirectURL = '/login';\n\t  if (typeof options === 'string') {\n\t    unauthenticatedRedirectURL = options;\n\t  } else if (options && options.redirectTo && options.redirectTo.length > 0) {\n\t    unauthenticatedRedirectURL = options.redirectTo;\n\t  }\n\t  var allOptions = options || {};\n\t\n\t  var setReturnTo = allOptions.setReturnTo === undefined ? true : options.setReturnTo;\n\t\n\t  return function areWeAuthenticated(req, res, next) {\n\t    // eslint-disable-line consistent-return\n\t    if (!req.isAuthenticated || !req.isAuthenticated()) {\n\t      if (setReturnTo && req.session) {\n\t        req.session.returnTo = req.originalUrl || req.url; // eslint-disable-line no-param-reassign\n\t      }\n\t      return res.redirect(unauthenticatedRedirectURL);\n\t    }\n\t    next();\n\t  };\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _express = __webpack_require__(3);\n\t\n\tvar _passport = __webpack_require__(6);\n\t\n\tvar _passport2 = _interopRequireDefault(_passport);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar routes = new _express.Router();\n\t\n\tfunction signinUser(req, res, next) {\n\t  _passport2.default.authenticate('local', function (err, user) {\n\t    // eslint-disable-line consistent-return\n\t    if (err || !user) {\n\t      res.statusMessage = 'Could not log in with that email and password combination.'; // eslint-disable-line no-param-reassign\n\t      res.status(422).end();\n\t    }\n\t    req.logIn(user, function (error) {\n\t      // eslint-disable-line consistent-return\n\t      if (error) {\n\t        return next(error);\n\t      }\n\t      res.cookie('snssl', 'y', { httpOnly: false });\n\t\n\t      // you can send a json response instead of redirecting the user\n\t      res.status(201).json({\n\t        success: true,\n\t        message: 'Logged in',\n\t        account: user\n\t      });\n\t    });\n\t  })(req, res, next);\n\t}\n\t\n\troutes.route('/sessions').post(signinUser);\n\t\n\troutes.route('/sessions').delete(function logThemOut(req, res) {\n\t  req.session.destroy();\n\t  req.logout();\n\t  res.clearCookie('snssl');\n\t  res.status(204).end();\n\t});\n\t\n\t/* Checks if a user is currently authenticated.\n\t * Technically, checks the cookie.\n\t */\n\troutes.route('/sessions').get(function isAuthenticated(req, res) {\n\t  if (!req.isAuthenticated || !req.isAuthenticated()) {\n\t    res.status(204).end();\n\t  }\n\t  res.status(403).end();\n\t});\n\t\n\texports.default = routes;\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.RecipientController = exports.Recipient = exports.recipientRoutes = undefined;\n\t\n\tvar _routes = __webpack_require__(28);\n\t\n\tvar _routes2 = _interopRequireDefault(_routes);\n\t\n\tvar _model = __webpack_require__(30);\n\t\n\tvar _model2 = _interopRequireDefault(_model);\n\t\n\tvar _controller = __webpack_require__(29);\n\t\n\tvar RecipientController = _interopRequireWildcard(_controller);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.recipientRoutes = _routes2.default;\n\texports.Recipient = _model2.default;\n\texports.RecipientController = RecipientController;\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _express = __webpack_require__(3);\n\t\n\tvar _controller = __webpack_require__(29);\n\t\n\tvar _Authentication = __webpack_require__(22);\n\t\n\tvar routes = new _express.Router();\n\troutes.get('/recipients', (0, _Authentication.ensureLoggedIn)(), _controller.getRecipientsEndpoint);\n\troutes.post('/recipients', (0, _Authentication.ensureLoggedIn)(), _controller.addRecipientEndpoint);\n\troutes.put('/recipients/:recipientId', (0, _Authentication.ensureLoggedIn)(), _controller.updateRecipientEndpoint);\n\troutes.delete('/recipients/:recipientId', (0, _Authentication.ensureLoggedIn)(), _controller.removeRecipientEndpoint);\n\t\n\texports.default = routes;\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.removeRecipientEndpoint = exports.updateRecipientEndpoint = exports.addRecipientEndpoint = exports.getRecipientsEndpoint = undefined;\n\t\n\tvar _model = __webpack_require__(30);\n\t\n\t/* Returns either the current account's accountId or, if onBehalfOfId is passed in\n\t *  to the body, it will verify if the current account can act on behalf of the passed\n\t *  in id and return that.\n\t *  @param {object} req - the request object that has a user account attached\n\t *  @returns {string} accountId - the accountId to use in searches.\n\t */\n\tvar activeAccountId = function getAccount(req) {\n\t  var currentAccount = req.user;\n\t  var onBehalfOfId = req.body.onBehalfOfId;\n\t  if (onBehalfOfId && onBehalfOfId.length > 0) {\n\t    if (currentAccount && currentAccount.canActOnBehalfOf(onBehalfOfId)) {\n\t      return onBehalfOfId;\n\t    }\n\t  }\n\t  return req.user.accountId;\n\t};\n\t\n\t/* Get all of the recipients for the accountId.\n\t * Params needed in req.body:\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the search parameters.\n\t */\n\tvar getRecipientsEndpoint = function getRecipientsEndpoint(req, res) {\n\t  // eslint-disable-line consistent-return\n\t  var accountId = activeAccountId(req);\n\t  if (!accountId) {\n\t    return res.status(422).json({ success: false, message: 'No accountId provided' });\n\t  }\n\t  _model.Recipient.findAllForId(accountId, false).then(function (recipients) {\n\t    var cleanRecipients = recipients.map(function jsonify(recipient) {\n\t      return recipient.toJSON();\n\t    });\n\t    console.log('Found these recipients');\n\t    console.dir(recipients);\n\t    res.status(201).json({\n\t      success: true,\n\t      recipients: cleanRecipients\n\t    });\n\t  }).catch(function (err) {\n\t    res.status(422).json({ success: false, message: err.message });\n\t  });\n\t};\n\t\n\t/* Adds an recipient to the Recipients database based on the fields passed in.\n\t * Params needed in req.body:\n\t *   @param {string} email - the email address\n\t *   @param {string} displayName - the displayName for the recipient.\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the accountId to search for.\n\t */\n\tvar addRecipientEndpoint = function addRecipientEndpoint(req, res) {\n\t  var _req$body = req.body,\n\t      email = _req$body.email,\n\t      displayName = _req$body.displayName;\n\t\n\t  var accountId = activeAccountId(req);\n\t  var newRecipient = new _model.Recipient({\n\t    email: email,\n\t    displayName: displayName,\n\t    ownerAccountId: accountId\n\t  });\n\t  console.log('Heres the new recipient');\n\t  console.dir(newRecipient);\n\t  newRecipient.save().then(function (createdRecipient) {\n\t    console.log('Created new recipient: ');\n\t    console.dir(createdRecipient);\n\t    console.dir(createdRecipient.toObject());\n\t    res.status(201).json({\n\t      success: true,\n\t      message: 'Successfully created recipient',\n\t      recipient: createdRecipient.toJSON()\n\t    });\n\t  }).catch(function (err) {\n\t    console.log('Recipient creation error: ');\n\t    console.dir(err);\n\t    var errorMessage = 'Recipient could not be created.';\n\t    if (err.code === 11000) {\n\t      errorMessage = 'Recipient already exists';\n\t    } else if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.status(422).json({ success: false, messages: errorMessage });\n\t  });\n\t};\n\t\n\t/* Updates a recipient\n\t * Params needed in req.body:\n\t *   @param {string=} email (optional) - the email address to update.\n\t *   @param {string=} displayName (optional) - the displayName to update.\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param (number) recipientId - Will be pulled from req.params or req.body (body takes priority)\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the accountId to search for.\n\t */\n\tvar updateRecipientEndpoint = function updateRecipientEndpoint(req, res) {\n\t  var recipientId = req.params.recipientId;\n\t  if (req.body.recipientId) {\n\t    recipientId = req.body.recipientId;\n\t  }\n\t  var _req$body2 = req.body,\n\t      email = _req$body2.email,\n\t      displayName = _req$body2.displayName,\n\t      status = _req$body2.status;\n\t\n\t  if (!recipientId) {\n\t    res.status(422).json({ success: false, messages: 'No recipientId provided.' });\n\t  }\n\t\n\t  var accountId = activeAccountId(req);\n\t  var updates = {};\n\t  if (email && email.length > 0) updates.email = email;\n\t  if (displayName && displayName.length > 0) updates.displayName = displayName;\n\t  if (status && status.length > 0) updates.status = status;\n\t\n\t  if (Object.keys(updates).length === 0) {\n\t    res.status(422).json({ success: false, messages: 'Nothing to update.' });\n\t  }\n\t  _model.Recipient.update(recipientId, accountId, updates).then(function (updatedRecipient) {\n\t    console.log('Updated recipient: ');\n\t    console.dir(updatedRecipient);\n\t    console.dir(updatedRecipient.toObject());\n\t    res.status(201).json({\n\t      success: true,\n\t      message: 'Successfully updated recipient',\n\t      recipient: updatedRecipient.toJSON()\n\t    });\n\t  }).catch(function (err) {\n\t    console.log('Recipient update error: ');\n\t    console.dir(err);\n\t    var errorMessage = 'Recipient could not be updated.';\n\t    if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.status(422).json({ success: false, messages: errorMessage });\n\t  });\n\t};\n\t\n\t/* Removes a recipient (marks the status to 'removed')\n\t * Params needed in req.body:\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param (number) recipientId - Will be pulled from req.params or req.body (body takes priority)\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the accountId to search for.\n\t */\n\tvar removeRecipientEndpoint = function removeRecipientEndpoint(req, res) {\n\t  var recipientId = req.params.recipientId;\n\t  if (req.body.recipientId) {\n\t    recipientId = req.body.recipientId;\n\t  }\n\t  if (!recipientId) {\n\t    res.status(422).json({ success: false, messages: 'No recipientId provided.' });\n\t  }\n\t\n\t  var accountId = activeAccountId(req);\n\t  _model.Recipient.update(recipientId, accountId, { status: _model.RecipientStatus.REMOVED }).then(function (updatedRecipient) {\n\t    console.log('Updated recipient: ');\n\t    console.dir(updatedRecipient);\n\t    console.dir(updatedRecipient.toObject());\n\t    res.status(201).json({\n\t      success: true,\n\t      message: 'Successfully removed recipient'\n\t    });\n\t  }).catch(function (err) {\n\t    console.log('Recipient removal error: ');\n\t    console.dir(err);\n\t    var errorMessage = 'Recipient could not be removed.';\n\t    if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.status(422).json({ success: false, messages: errorMessage });\n\t  });\n\t};\n\t\n\texports.getRecipientsEndpoint = getRecipientsEndpoint;\n\texports.addRecipientEndpoint = addRecipientEndpoint;\n\texports.updateRecipientEndpoint = updateRecipientEndpoint;\n\texports.removeRecipientEndpoint = removeRecipientEndpoint;\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.RecipientStatus = exports.Recipient = undefined;\n\t\n\tvar _mongoose = __webpack_require__(12);\n\t\n\tvar _mongoose2 = _interopRequireDefault(_mongoose);\n\t\n\tvar _appraise = __webpack_require__(19);\n\t\n\tvar _idier = __webpack_require__(16);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar RecipientStatus = {\n\t  VALIDATING: 'validating',\n\t  ACTIVE: 'active',\n\t  REMOVED: 'removed',\n\t  BOUNCING: 'bouncing',\n\t  UNSUBSCRIBED: 'unsubscribed'\n\t};\n\t\n\t/* Recipient schema represents all recipients for an account.\n\t */\n\tvar RecipientSchema = new _mongoose.Schema({\n\t  status: {\n\t    type: _mongoose.Schema.Types.String,\n\t    default: RecipientStatus.ACTIVE,\n\t    enum: [RecipientStatus.VALIDATING, RecipientStatus.ACTIVE, RecipientStatus.REMOVED, RecipientStatus.BOUNCING, RecipientStatus.UNSUBSCRIBED]\n\t  },\n\t  recipientId: {\n\t    type: _mongoose.Schema.Types.Number,\n\t    unique: true,\n\t    required: true\n\t  },\n\t  ownerAccountId: {\n\t    type: _mongoose.Schema.Types.Number,\n\t    required: true,\n\t    index: true\n\t  },\n\t  email: {\n\t    type: String,\n\t    trim: true\n\t  },\n\t  phoneNumber: {\n\t    type: String\n\t  },\n\t  phoneType: {\n\t    type: String\n\t  },\n\t  displayName: {\n\t    type: String,\n\t    trim: true\n\t  },\n\t  dateCreated: {\n\t    type: Date,\n\t    default: Date.now\n\t  },\n\t  dateUpdated: {\n\t    type: Date,\n\t    default: Date.now\n\t  },\n\t  dateRecipientValidated: {\n\t    type: Date\n\t  },\n\t  dateUnsubscribed: {\n\t    type: Date\n\t  },\n\t  unsubscriptionReason: {\n\t    type: String\n\t  },\n\t  dateRemoved: {\n\t    type: Date\n\t  }\n\t});\n\t\n\t/* If it's a new recipient, create an recipientId for it. */\n\tRecipientSchema.pre('validate', function preValidateRecipient(next) {\n\t  console.log('Called pre save recipient');\n\t  if (!this.recipientId) {\n\t    this.recipientId = (0, _idier.idier)();\n\t  }\n\t  next();\n\t});\n\t\n\t/* Update the dateUpdated field on save. */\n\tRecipientSchema.pre('save', true, function updateRecipientDate(next, done) {\n\t  this.dateUpdated = new Date();\n\t  next();\n\t  done();\n\t});\n\t\n\t/* Does the pre-save validations.\n\t * Why here instead of on each individual field? Allows us to return multiple errors at once.\n\t */\n\tRecipientSchema.pre('save', true, function preRecipientSaveValidations(next, done) {\n\t  var errorMessages = [];\n\t  var emailAppraisal = (0, _appraise.appraiseEmail)(this.email);\n\t  if (emailAppraisal.length > 0) {\n\t    this.invalidate('email', emailAppraisal.join(', '));\n\t    errorMessages.push(emailAppraisal.join(', '));\n\t  }\n\t\n\t  var displayNameAppraisal = (0, _appraise.appraiseDisplayName)(this.displayName);\n\t  if (displayNameAppraisal.length > 0) {\n\t    this.invalidate('displayName', displayNameAppraisal.join(', '));\n\t    errorMessages.push(displayNameAppraisal.join(' '));\n\t  }\n\t  if (errorMessages.length > 0) {\n\t    done(new Error(errorMessages.join(' ')));\n\t  }\n\t  next();\n\t  done();\n\t});\n\t\n\t/* Remove password and pepper from exported json && object\n\t * Based on: http://ksloan.net/tips-for-using-mongoose-schemas-with-express-mongo-express-node-stack/\n\t */\n\tRecipientSchema.set('toJSON', {\n\t  transform: function transformJSON(doc, objRepresentation) {\n\t    return {\n\t      recipientId: objRepresentation.recipientId,\n\t      email: objRepresentation.email,\n\t      displayName: objRepresentation.displayName,\n\t      dateCreated: objRepresentation.dateCreated,\n\t      dateUnsubscribed: objRepresentation.dateUnsubscribed,\n\t      status: objRepresentation.status\n\t    };\n\t  }\n\t});\n\t\n\t/* Find a recipient by an recipientId\n\t * @param {number} recipientId - the recipient id\n\t * @returns {promise} - a promise to find something\n\t */\n\tRecipientSchema.statics.findOneRecipient = function findRecipientById(recipientId) {\n\t  return this.findOne({ recipientId: recipientId }).exec();\n\t};\n\t\n\t/* Find a recipient by an recipientId and update the appropriate fields.\n\t * @param {number} recipientId - the recipient id\n\t * @param {object} fieldsToUpdate - the fields and their values to update to.\n\t * @returns {promise} - a promise to find something\n\t * @note: We do it this way instead of findOneAndUpdate because update and valdiation hooks are\n\t *   not called on findOneAndUpdate.\n\t */\n\tRecipientSchema.statics.update = function findARecipientById(recipientId, ownerId, fieldsToUpdate) {\n\t  return this.findOne({ recipientId: recipientId, ownerAccountId: ownerId }).exec().then(function (foundItem) {\n\t    var foundRecipient = foundItem;\n\t    var fieldsToUpdateKeys = Object.keys(fieldsToUpdate);\n\t    fieldsToUpdateKeys.forEach(function modifyItem(key) {\n\t      foundRecipient[key] = fieldsToUpdate[key];\n\t    });\n\t    return foundRecipient.save();\n\t  });\n\t};\n\t\n\t/* Find a recipient by an email address\n\t * @param {string} email - the associated email address\n\t * @returns {promise} - a promise to find something\n\t */\n\tRecipientSchema.statics.findOneByEmail = function findRecipientByEmail(email) {\n\t  return this.findOne({ email: email }).exec();\n\t};\n\t\n\t/* Find all recipients for an accountId\n\t * @param {string} accountId - the accountId to search for\n\t * @returns {promise} - a promise to find something\n\t */\n\tRecipientSchema.statics.findAllForId = function findRecipients(accountId) {\n\t  var lean = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t  if (lean) {\n\t    return this.find({ ownerAccountId: accountId }).lean().exec();\n\t  }\n\t  return this.find({ ownerAccountId: accountId }).exec();\n\t};\n\t\n\t/* Determine total number of recipients for account\n\t * @param {number} - accountId\n\t */\n\tRecipientSchema.statics.totalForAccountId = function countRecipients(accountId) {\n\t  return this.count({ ownerAccountId: accountId }).exec();\n\t};\n\t\n\t/* Compile the schema into a model\n\t * http://mongoosejs.com/docs/models.html\n\t */\n\tvar Recipient = _mongoose2.default.model('Recipient', RecipientSchema);\n\t\n\texports.Recipient = Recipient;\n\texports.RecipientStatus = RecipientStatus;\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.PostController = exports.Post = exports.postRoutes = undefined;\n\t\n\tvar _routes = __webpack_require__(32);\n\t\n\tvar _routes2 = _interopRequireDefault(_routes);\n\t\n\tvar _model = __webpack_require__(34);\n\t\n\tvar _model2 = _interopRequireDefault(_model);\n\t\n\tvar _controller = __webpack_require__(33);\n\t\n\tvar PostController = _interopRequireWildcard(_controller);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.postRoutes = _routes2.default;\n\texports.Post = _model2.default;\n\texports.PostController = PostController;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _express = __webpack_require__(3);\n\t\n\tvar _controller = __webpack_require__(33);\n\t\n\tvar _Authentication = __webpack_require__(22);\n\t\n\tvar routes = new _express.Router();\n\troutes.get('/posts', (0, _Authentication.ensureLoggedIn)(), _controller.getPostsEndpoint);\n\troutes.post('/posts', (0, _Authentication.ensureLoggedIn)(), _controller.addPostEndpoint);\n\troutes.put('/posts/:postId', (0, _Authentication.ensureLoggedIn)(), _controller.updatePostEndpoint);\n\troutes.delete('/posts/:postId', (0, _Authentication.ensureLoggedIn)(), _controller.removePostEndpoint);\n\t\n\texports.default = routes;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.removePostEndpoint = exports.updatePostEndpoint = exports.addPostEndpoint = exports.getPostsEndpoint = undefined;\n\t\n\tvar _model = __webpack_require__(34);\n\t\n\t/* Returns either the current account's accountId or, if onBehalfOfId is passed in\n\t *  to the body, it will verify if the current account can act on behalf of the passed\n\t *  in id and return that.\n\t *  @param {object} req - the request object that has a user account attached\n\t *  @returns {string} accountId - the accountId to use in searches.\n\t *   TODO: need to move it to it's own module since we're duplicating it in every controller.\n\t */\n\tvar activeAccountId = function getAccount(req) {\n\t  var currentAccount = req.user;\n\t  var onBehalfOfId = req.body.onBehalfOfId;\n\t  if (onBehalfOfId && onBehalfOfId.length > 0) {\n\t    if (currentAccount && currentAccount.canActOnBehalfOf(onBehalfOfId)) {\n\t      return onBehalfOfId;\n\t    }\n\t  }\n\t  if (req.user && req.user.accountId) {\n\t    return req.user.accountId;\n\t  }\n\t  return null;\n\t};\n\t\n\t/* Get all of the posts for the accountId.\n\t * Params needed in req.body:\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the search parameters.\n\t */\n\tvar getPostsEndpoint = function getPostsEndpoint(req, res) {\n\t  // eslint-disable-line consistent-return\n\t  var accountId = activeAccountId(req);\n\t  if (!accountId) {\n\t    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  }\n\t  _model.Post.findAllForId(accountId, false).then(function (items) {\n\t    var cleanedItems = items.map(function jsonify(mappedItem) {\n\t      return mappedItem.toJSON();\n\t    });\n\t    res.status(200).json({\n\t      success: true,\n\t      posts: cleanedItems\n\t    });\n\t  }).catch(function (err) {\n\t    res.statusMessage = err.message; // eslint-disable-line no-param-reassign\n\t    res.status(404).end();\n\t  });\n\t};\n\t\n\t/* Adds a post to the Post database based on the fields passed in.\n\t * Params needed in req.body:\n\t *   @param {string} message - the main message body\n\t *   @param {string=} subject (optional) - subject of the post.\n\t *   @param {array[number]} mediaIds - the mediaIds associated with this post.\n\t *   @param {string=} status (optional) - Must be one of PostStatus (see Post model).\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the accountId to search for.\n\t */\n\tvar addPostEndpoint = function addPostEndpoint(req, res) {\n\t  var accountId = activeAccountId(req);\n\t  if (!accountId) {\n\t    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  }\n\t  var _req$body = req.body,\n\t      message = _req$body.message,\n\t      subject = _req$body.subject,\n\t      mediaIds = _req$body.mediaIds,\n\t      status = _req$body.status;\n\t\n\t  var newItem = new _model.Post({\n\t    message: message,\n\t    subject: subject,\n\t    mediaIds: mediaIds,\n\t    status: status,\n\t    ownerAccountId: accountId\n\t  });\n\t  newItem.save().then(function (createdItem) {\n\t    var cleanedPost = createdItem.toJSON();\n\t    res.status(201).json({\n\t      success: true,\n\t      message: 'Successfully created post',\n\t      recipient: cleanedPost\n\t    });\n\t  }).catch(function (err) {\n\t    var errorMessage = 'Post could not be created.';\n\t    if (err.code === 11000) {\n\t      errorMessage = 'Post already exists';\n\t    } else if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  });\n\t};\n\t\n\t/* Updates a post\n\t *   @param {string} message - the main message body\n\t *   @param {string=} subject (optional) - subject of the post.\n\t *   @param {array[number]} mediaIds - the mediaIds associated with this post.\n\t *   @param {string=} status (optional) - Must be one of PostStatus (see Post model).\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param (number) postId - Will be pulled from req.params or req.body (body takes priority)\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the accountId to search for.\n\t */\n\tvar updatePostEndpoint = function updatePostEndpoint(req, res) {\n\t  var accountId = activeAccountId(req);\n\t  if (!accountId) {\n\t    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  }\n\t  var itemId = req.params.postId;\n\t  if (req.body.postId) {\n\t    itemId = req.body.postId;\n\t  }\n\t  if (!itemId) {\n\t    res.status(422).json({ success: false, messages: 'No PostId provided.' });\n\t  }\n\t  var _req$body2 = req.body,\n\t      message = _req$body2.message,\n\t      subject = _req$body2.subject,\n\t      mediaIds = _req$body2.mediaIds,\n\t      status = _req$body2.status;\n\t\n\t  var updates = {};\n\t  if (message && message.length > 0) updates.message = message;\n\t  if (subject && subject.length > 0) updates.subject = subject;\n\t  if (mediaIds && mediaIds.length > 0) updates.mediaIds = mediaIds;\n\t  if (status && status.length > 0) updates.status = status;\n\t\n\t  if (Object.keys(updates).length === 0) {\n\t    res.status(422).json({ success: false, messages: 'Nothing to update.' });\n\t  }\n\t  _model.Post.update(itemId, accountId, updates).then(function (updatedItem) {\n\t    res.status(200).json({\n\t      success: true,\n\t      message: 'Successfully updated post',\n\t      post: updatedItem.toJSON()\n\t    });\n\t  }).catch(function (err) {\n\t    var errorMessage = 'Post could not be updated.';\n\t    if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  });\n\t};\n\t\n\t/* Removes a post (marks the status to 'removed')\n\t * Params needed in req.body:\n\t *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n\t *      can act on behalf of it.\n\t *  @param (number) postId - Will be pulled from req.params or req.body (body takes priority)\n\t *  @param {number} accountId - Will be pulled from req.user.\n\t *  Uses activeAccountId() to get the accountId to search for.\n\t */\n\tvar removePostEndpoint = function removePostEndpoint(req, res) {\n\t  var accountId = activeAccountId(req);\n\t  if (!accountId) {\n\t    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  }\n\t  var itemId = req.params.postId;\n\t  if (req.body.postId) {\n\t    itemId = req.body.postId;\n\t  }\n\t  if (!itemId) {\n\t    res.statusMessage = 'No postId provided.'; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  }\n\t  _model.Post.update(itemId, accountId, { status: _model.PostStatus.REMOVED }).then(function () {\n\t    res.status(204).end();\n\t  }).catch(function (err) {\n\t    var errorMessage = 'Post could not be removed.';\n\t    if (err.message) {\n\t      errorMessage = err.message;\n\t    }\n\t    res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n\t    res.status(422).end();\n\t  });\n\t};\n\t\n\texports.getPostsEndpoint = getPostsEndpoint;\n\texports.addPostEndpoint = addPostEndpoint;\n\texports.updatePostEndpoint = updatePostEndpoint;\n\texports.removePostEndpoint = removePostEndpoint;\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.PostStatus = exports.Post = undefined;\n\t\n\tvar _mongoose = __webpack_require__(12);\n\t\n\tvar _mongoose2 = _interopRequireDefault(_mongoose);\n\t\n\tvar _idier = __webpack_require__(16);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* The maximum we can return from a search */\n\tvar MAX_RETURN_LIMIT = 100;\n\t\n\t/* Enum for the post.status field */\n\tvar PostStatus = {\n\t  DRAFT: 'draft',\n\t  POSTED: 'posted',\n\t  REMOVED: 'removed'\n\t};\n\t\n\t/* Post schema represents all posts.\n\t * https://developers.facebook.com/docs/graph-api/reference/v2.8/post\n\t */\n\tvar PostSchema = new _mongoose.Schema({\n\t  status: {\n\t    type: _mongoose.Schema.Types.String,\n\t    default: PostStatus.POSTED,\n\t    enum: [PostStatus.DRAFT, PostStatus.POSTED, PostStatus.REMOVED]\n\t  },\n\t  postId: {\n\t    type: _mongoose.Schema.Types.Number,\n\t    unique: true,\n\t    required: true\n\t  },\n\t  message: {\n\t    type: _mongoose.Schema.Types.String,\n\t    required: true\n\t  },\n\t  subject: {\n\t    type: _mongoose.Schema.Types.String\n\t  },\n\t  mediaIds: {\n\t    type: _mongoose.Schema.Types.Array\n\t  },\n\t  ownerAccountId: {\n\t    type: _mongoose.Schema.Types.Number,\n\t    required: true,\n\t    index: true\n\t  },\n\t  dateCreated: {\n\t    type: Date,\n\t    default: Date.now\n\t  },\n\t  dateUpdated: {\n\t    type: Date,\n\t    default: Date.now\n\t  }\n\t});\n\t\n\t/* If it's a new post, create an postId for it. */\n\tPostSchema.pre('validate', function preValidatePost(next) {\n\t  if (!this.postId) {\n\t    this.postId = (0, _idier.idier)();\n\t  }\n\t  next();\n\t});\n\t\n\t/* Update the dateUpdated field on save. */\n\tPostSchema.pre('save', true, function updatePostDate(next, done) {\n\t  this.dateUpdated = new Date();\n\t  next();\n\t  done();\n\t});\n\t\n\t/*\n\t * Based on: http://ksloan.net/tips-for-using-mongoose-schemas-with-express-mongo-express-node-stack/\n\t */\n\tPostSchema.set('toJSON', {\n\t  transform: function transformJSON(doc, objRepresentation) {\n\t    return {\n\t      postId: objRepresentation.postId,\n\t      message: objRepresentation.message,\n\t      subject: objRepresentation.subject,\n\t      mediaIds: objRepresentation.mediaIds,\n\t      ownerAccountId: objRepresentation.ownerAccountId,\n\t      dateCreated: objRepresentation.dateCreated,\n\t      dateUpdated: objRepresentation.dateUpdated,\n\t      status: objRepresentation.status\n\t    };\n\t  }\n\t});\n\t\n\t/* Find a post by an postId\n\t * @param {number} postId - the post identifier\n\t * @returns {promise} - a promise to find something\n\t */\n\tPostSchema.statics.findOnePost = function findPostById(postId) {\n\t  return this.findOne({ postId: postId }).exec();\n\t};\n\t\n\t/* Find a post by an postId and update the appropriate fields.\n\t * @param {number} recipientId - the recipient id\n\t * @param {number} ownerId - the owner id\n\t * @param {object} fieldsToUpdate - the fields and their values to update to.\n\t * @returns {promise} - a promise to find and update something\n\t * @note: We do it this way instead of findOneAndUpdate because update and valdiation hooks are\n\t *   not called on findOneAndUpdate.\n\t */\n\tPostSchema.statics.update = function updatePostById(postId, ownerId, fieldsToUpdate) {\n\t  return this.findOne({ postId: postId, ownerAccountId: ownerId }).exec().then(function (foundItem) {\n\t    var foundPost = foundItem;\n\t    var fieldsToUpdateKeys = Object.keys(fieldsToUpdate);\n\t    fieldsToUpdateKeys.forEach(function modifyItem(key) {\n\t      foundPost[key] = fieldsToUpdate[key];\n\t    });\n\t    return foundPost.save();\n\t  });\n\t};\n\t\n\t/* Find all posts for an accountId\n\t * @param {string} accountId - the accountId to search for\n\t * @param {number} limit - the number to find.\n\t * @param {number} beforeId - the identifier to sort before. If this is passed, limit is used.\n\t * @returns {promise} - a promise to find something\n\t */\n\tPostSchema.statics.findAllForId = function allPosts(accountId) {\n\t  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n\t  var beforeId = arguments[2];\n\t\n\t  var limiter = limit;\n\t  if (limiter > MAX_RETURN_LIMIT) limiter = MAX_RETURN_LIMIT;\n\t\n\t  if (beforeId) {\n\t    return this.find({ ownerAccountId: accountId, postId: { $lte: beforeId } }).limit(limiter).sort({ postId: -1 }).exec();\n\t  }\n\t  return this.find({ ownerAccountId: accountId }).limit(limiter).sort({ postId: -1 }).exec();\n\t};\n\t\n\t/* Determine total number of posts for account\n\t * @param {number} - accountId\n\t */\n\tPostSchema.statics.totalForAccountId = function countPosts(accountId) {\n\t  return this.count({ ownerAccountId: accountId }).exec();\n\t};\n\t\n\t/* Compile the schema into a model\n\t * http://mongoosejs.com/docs/models.html\n\t */\n\tvar Post = _mongoose2.default.model('Post', PostSchema);\n\t\n\texports.Post = Post;\n\texports.PostStatus = PostStatus;\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _dotenv = __webpack_require__(36);\n\t\n\tvar _dotenv2 = _interopRequireDefault(_dotenv);\n\t\n\tvar _requireEnvironmentVariables = __webpack_require__(37);\n\t\n\tvar _requireEnvironmentVariables2 = _interopRequireDefault(_requireEnvironmentVariables);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* 'As early as possible in your application, require and configure dotenv.'\n\t *   - https://www.npmjs.com/package/dotenv\n\t *\n\t * However, we aren't going to load these in production as it could lead to sloppy deploys.\n\t */\n\tif (process.env.NODE_ENV && process.env.NODE_ENV !== 'production') {\n\t  _dotenv2.default.load();\n\t} else {\n\t  _dotenv2.default.load();\n\t}\n\t\n\t/* If any of the environment variables(process.env.REDIS_URL) don't exist,\n\t *   the process exits with code 400.\n\t * https://github.com/bjoshuanoah/require-environment-variables\n\t */\n\t(0, _requireEnvironmentVariables2.default)(['REDIS_URL', 'MONGODB_URI', 'API_SERVER_PORT', 'MAIN_SERVER_PORT', 'ACCOUNT_PEPPER_1', 'ACCOUNT_ENCRYPT_CURRENT_PEPPER', 'IDIER_WORKER_ID']);\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"dotenv\");\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"require-environment-variables\");\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _mongoose = __webpack_require__(12);\n\t\n\tvar _mongoose2 = _interopRequireDefault(_mongoose);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar MONGODB_URI = process.env.MONGODB_URI;\n\t\n\tvar options = {\n\t  server: { socketOptions: { keepAlive: 300000, connectTimeoutMS: 30000 } },\n\t  replset: { socketOptions: { keepAlive: 300000, connectTimeoutMS: 30000 } }\n\t};\n\t\n\t_mongoose2.default.Promise = global.Promise;\n\t\n\t/* Connect to mongo */\n\t_mongoose2.default.connect(MONGODB_URI, options);\n\t_mongoose2.default.connection.once('open', function () {\n\t  return console.log('Connected to MongoDb: running on ' + MONGODB_URI);\n\t}).on('error', function (err) {\n\t  return console.warn('Warning', err);\n\t});\n\t\n\texports.default = _mongoose2.default;\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _redis = __webpack_require__(40);\n\t\n\tvar _redis2 = _interopRequireDefault(_redis);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar REDIS_URL = process.env.REDIS_URL;\n\t\n\t/* Connect to redis */\n\tvar redisClient = _redis2.default.createClient(REDIS_URL);\n\t\n\tredisClient.on('error', function redisErrorReport(err) {\n\t  console.log('Redis connection error ' + err);\n\t});\n\t\n\texports.default = redisClient;\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"redis\");\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"connect-redis\");\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// server.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a5ee6fc2da1e76918a25","/* Base imports */\nimport { Server } from 'http';\nimport bodyParser from 'body-parser';\nimport express from 'express';\nimport session from 'express-session';\nimport morgan from 'morgan';\nimport passport from 'passport';\n/* Routes */\nimport { accountRoutes, recipientRoutes, authenticationRoutes, postRoutes } from './modules';\n/* Configurations */\nimport '../config/environment';\nimport mongooseConnection from '../config/mongoConnect';\nimport redisClient from '../config/redisConnect';\n\nconst RedisStore = require('connect-redis')(session);\n\nlet port = process.env.API_SERVER_PORT;\nif (!port) {\n  port = 3006;\n}\n\nconst app = express();\n\n/* Middleware setup */\napp.use((err, req, res, next) => {\n  if (res.headersSent) next(err);\n  res.status(err.status || port).render('500');\n});\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({\n  name: 'snss',\n  secret: 'MmyWTLNNsTi15LYHz8FP',\n  resave: true,\n  saveUninitialized: false,\n  store: new RedisStore({ client: redisClient }),\n}));\napp.use(passport.initialize());\napp.use(passport.session());\napp.use(morgan('combined'));\n\n/* Routes */\napp.use('/api/v1', [accountRoutes, recipientRoutes, authenticationRoutes, postRoutes]);\n\napp.get('/', function baseReturn(req, res) {\n  res.send('Hello - this is the api server. You probably want a more interesting endpoint.');\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Closing server.');\n  app.close();\n});\n\napp.on('close', () => {\n  console.log('Closing redis.');\n  redisClient.quit();\n  mongooseConnection.close();\n});\n\n/* Start the API Server */\nconst server = Server(app);\nserver.listen(port, function reportOnListen(error) {\n  if (error) {\n    console.log(`API Server ERROR on startup: ${error}`);\n  } else {\n    console.log(`API Server listening on http://localhost:${port}.`);\n  }\n});\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/apiserver.js","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 1\n// module chunks = 0","module.exports = require(\"body-parser\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"body-parser\"\n// module id = 2\n// module chunks = 0","module.exports = require(\"express\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"express\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"express-session\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"express-session\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"morgan\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"morgan\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"passport\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"passport\"\n// module id = 6\n// module chunks = 0","export * from './Account';\nexport * from './Recipient';\nexport * from './Authentication';\nexport * from './Post';\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/index.js","import accountRoutes from './routes';\nimport Account from './model';\nimport * as AccountController from './controller';\n\nexport { accountRoutes, Account, AccountController };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Account/index.js","import { Router } from 'express';\nimport { addAccountEndpoint, getAccountInfoEndpoint } from './controller';\nimport { ensureLoggedIn } from '../Authentication';\n\nconst routes = new Router();\n\nroutes.route('/account')\n  .post(addAccountEndpoint);\n\nroutes.get('/account', ensureLoggedIn(), getAccountInfoEndpoint);\n\nexport default routes;\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Account/routes.js","import Account from './model';\n\n/* Returns either the current account's accountId or, if onBehalfOfId is passed in\n *  to the body, it will verify if the current account can act on behalf of the passed\n *  in id and return that.\n *  @param {object} req - the request object that has a user account attached\n *  @returns {string} accountId - the accountId to use in searches.\n *   TODO: need to move it to it's own module since we're duplicating it in every controller.\n */\nconst activeAccountId = function getAccount(req) {\n  const currentAccount = req.user;\n  const onBehalfOfId = req.body.onBehalfOfId;\n  if (onBehalfOfId && onBehalfOfId.length > 0) {\n    if (currentAccount && currentAccount.canActOnBehalfOf(onBehalfOfId)) {\n      return onBehalfOfId;\n    }\n  }\n  if (req.user && req.user.accountId) {\n    return req.user.accountId;\n  }\n  return null;\n};\n\n/* Adds an account to the Accounts database based on the fields passed in.\n * Params needed in body:\n *   @param {string} email - the email address\n *   @param {string} password - the user's password. Must pass owasp tests.\n *   @param {string} displayName - the name to display on the users page.\n */\nconst addAccountEndpoint = (req, res) => {\n  const { email, password, displayName } = req.body;\n  const newAccount = new Account({ email, password, displayName });\n  newAccount.setPassword(password)\n    .then(() => { // eslint-disable-line arrow-body-style\n      return newAccount.save();\n    })\n    .then((createdAccount) => {\n      const cleanedAccount = createdAccount.toJSON();\n      res.status(201).json({\n        success: true,\n        message: 'Successfully Registered',\n        account: cleanedAccount,\n      });\n    })\n    .catch((err) => {\n      if (err.code === 11000) {\n        res.statusMessage = 'Account with that email already exists'; // eslint-disable-line no-param-reassign\n        res.status(409).end();\n        return;\n      }\n      let errorMessage = 'Account could not be created.';\n      if (err.message) {\n        errorMessage = err.message;\n      }\n      res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n      res.status(422).end();\n    });\n};\n\n/* Get account info for accountId.\n * Params needed in req.body:\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the search parameters.\n */\nconst getAccountInfoEndpoint = (req, res) => { // eslint-disable-line consistent-return\n  const accountId = activeAccountId(req);\n  if (!accountId) {\n    return res.status(422).json({ success: false, message: 'No accountId provided' });\n  }\n  Account.findOneAccount(accountId, false)\n    .then((item) => {\n      const cleanedItem = item.toJSON();\n      res.status(201).json({\n        success: true,\n        account: cleanedItem,\n      });\n    })\n    .catch((err) => {\n      res.statusMessage = err.message; // eslint-disable-line no-param-reassign\n      res.status(422).end();\n    });\n};\n\nconst updateAccountEndpoint = (req, res) => {\n  res.status(418).json({\n    message: 'Brewing',\n  });\n};\n\nexport { addAccountEndpoint, updateAccountEndpoint, getAccountInfoEndpoint };\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Account/controller.js","import mongoose, { Schema } from 'mongoose';\nimport { encryptPassword, passwordsMatch } from './passwordEncryption';\nimport { idier } from '../../../shared/helpers/idier';\nimport { appraiseEmail, appraiseDisplayName, appraisePassword } from '../../../shared/helpers/appraise';\n\n/* The various states an account can be in. Used in the schema for account.accountType.\n */\nconst AccountType = {\n  NORMAL: 'normal',\n  ADMIN: 'admin',\n  CUSTSERVICE: 'custservice',\n  BANNED: 'banned',\n};\n\n/* Account schema represents all accounts.\n * Note: We are not using the pepperId yet, there's only one pepper\n */\nconst AccountSchema = new Schema({\n  accountId: {\n    type: Schema.Types.Number,\n    unique: true,\n    required: true,\n  },\n  accountType: {\n    type: String,\n    enum: [AccountType.NORMAL, AccountType.ADMIN, AccountType.CUSTSERVICE, AccountType.BANNED],\n    default: AccountType.NORMAL,\n  },\n  email: {\n    type: String,\n    trim: true,\n    unique: true,\n    lowercase: true,\n  },\n  displayName: {\n    type: String,\n    trim: true,\n  },\n  encryptedPasswordHash: {\n    type: String,\n    trim: true,\n    required: true,\n  },\n  encryptedPasswordPepperId: {\n    type: String,\n  },\n  dateCreated: {\n    type: Date,\n    default: Date.now,\n  },\n  dateAccountValidated: {\n    type: Date,\n  },\n  dateUpdated: {\n    type: Date,\n    default: Date.now,\n  },\n});\n\n/* Remove password and pepper from exported json && object\n * Based on: http://ksloan.net/tips-for-using-mongoose-schemas-with-express-mongo-express-node-stack/\n */\nAccountSchema.set('toJSON', {\n  transform: function transformJSON(doc, objRepresentation) {\n    delete objRepresentation.encryptedPasswordHash;  // eslint-disable-line no-param-reassign\n    delete objRepresentation.passwordEncryptionPepperId;  // eslint-disable-line no-param-reassign\n    return objRepresentation;\n  },\n});\n\nAccountSchema.set('toJSON', {\n  transform: function transformJSON(doc, objRepresentation) {\n    return {\n      displayName: objRepresentation.displayName,\n      email: objRepresentation.email,\n      dateCreated: objRepresentation.dateCreated,\n      dateAccountValidated: objRepresentation.dateAccountValidated,\n      dateUpdated: objRepresentation.dateUpdated,\n      accountId: objRepresentation.accountId,\n      accountType: objRepresentation.accountType,\n    };\n  },\n});\n\nAccountSchema.set('toObject', {\n  transform: function transformObject(doc, objRepresentation) {\n    delete objRepresentation.encryptedPasswordHash;  // eslint-disable-line no-param-reassign\n    delete objRepresentation.passwordEncryptionPepperId;  // eslint-disable-line no-param-reassign\n    return objRepresentation;\n  },\n});\n\n/* Sets the account password (technically, encryptedPasswordHash)\n * Sends the password through hashing and encryption and saves it the the database.\n * returns {Promise}\n */\nAccountSchema.methods.setPassword = function setPassword(password) {\n  const self = this;\n\n  return Promise.resolve(appraisePassword(password))\n    .then(function checkAppraisal(appraisalMessages) {\n      if (appraisalMessages.length > 0) {\n        throw new Error(appraisalMessages.join(', '));\n      }\n      return password;\n    })\n    .then(function runHashing(passwordValue) {\n      return encryptPassword(passwordValue);\n    })\n    .then((encryptedValue) => {\n      console.log('Got encrypted value: ');\n      console.dir(encryptedValue);\n      self.encryptedPasswordHash = encryptedValue.encrypted;\n      self.encryptedPasswordPepperId = encryptedValue.pepperId;\n    })\n    .catch((err) => {\n      throw err;\n    });\n};\n\n/* If we don't have an accountID (say, on a new account), set one. */\nAccountSchema.pre('validate', function preValidateAddAccountId(next) {\n  if (!this.accountId) {\n    this.accountId = idier();\n  }\n  next();\n});\n\n/* Update the dateUpdated field on save. */\nAccountSchema.pre('save', true, function updateDate(next, done) {\n  this.dateUpdated = new Date();\n  next();\n  done();\n});\n\n/* Does the pre-save validations.\n * Why here instead of on each individual field? Allows us to return multiple errors at once.\n */\nAccountSchema.pre('save', true, function preSaveValidations(next, done) {\n  const errorMessages = [];\n  const emailAppraisal = appraiseEmail(this.email);\n  if (emailAppraisal.length > 0) {\n    this.invalidate('email', emailAppraisal.join(', '));\n    errorMessages.push(emailAppraisal.join(', '));\n  }\n\n  const displayNameAppraisal = appraiseDisplayName(this.displayName);\n  if (displayNameAppraisal.length > 0) {\n    this.invalidate('displayName', displayNameAppraisal.join(', '));\n    errorMessages.push(displayNameAppraisal.join(' '));\n  }\n  if (errorMessages.length > 0) {\n    done(new Error(errorMessages.join(' ')));\n  }\n  next();\n  done();\n});\n\nAccountSchema.methods.comparePassword = function comparePassword(candidate) {\n  return passwordsMatch(candidate, this.encryptedPasswordHash, this.encryptedPasswordPepperId);\n};\n\n/* Can this account act on behalf of another account?\n * @param {number} *ignored* the Account id to check against.\n * @returns {bool} true if account can act on behalf of accountId\n * @note Currently, only checks if this account has an account type of admin or customer service\n*/\nAccountSchema.methods.canActOnBehalfOf = function canActOnBehalfOf(accountId) {  // eslint-disable-line\n  if (this.accountType === AccountType.ADMIN\n    || this.accountType === AccountType.CUSTSERVICE) {\n    return true;\n  }\n  return false;\n};\n\n/* Find an account by an accountId\n * @param {number} accountId - the account id\n * @returns {promise} - a promise to find something\n */\nAccountSchema.statics.findOneAccount = function findAccountById(accountId) {\n  return this.findOne({ accountId: accountId }).exec();\n};\n\n/* Find an account by an email address\n * @param {string} email - the associated email address\n * @returns {promise} - a promise to find something\n */\nAccountSchema.statics.findOneByEmail = function findAccountByEmail(email) {\n  return this.findOne({ email: email }).exec();\n};\n\n/* Compile the schema into a model\n * http://mongoosejs.com/docs/models.html\n */\nconst Account = mongoose.model('Account', AccountSchema);\n\nexport default Account;\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Account/model.js","module.exports = require(\"mongoose\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mongoose\"\n// module id = 12\n// module chunks = 0","import { compare, hash } from 'bcrypt';\nimport crypto from 'crypto';\n\n/* Hashes the password into a SHA512 hex hash */\nconst hashPassword = function hashPassword(password) {\n  const hasher = crypto.createHash('sha512');\n  hasher.update(password);\n  const hashed = hasher.digest('hex');\n  return hashed;\n};\n\n/* Bcrypts a string (expects a hash) with 10 rounds and a per user salt\n * Salt is returned as part of the hash and thus saved.\n * Note that this version of bcrypt only takes the first 72 characters.\n  */\nconst bcryptHash = function bcryptHash(passwordhash) {\n  const saltRounds = 10;\n  return hash(passwordhash, saltRounds);\n};\n\n/* Encrypts the bcrypted string using aes256 using a pepper stored\n *   in the environment. This is what should be finally saved.\n */\nconst aesHash = function aesHash(passwordhash) {\n  const currentPepperId = process.env.ACCOUNT_ENCRYPT_CURRENT_PEPPER;\n  const pepper = process.env[currentPepperId];\n  const algorithm = 'aes-256-ctr';\n  const cipher = crypto.createCipher(algorithm, pepper);\n  let crypted = cipher.update(passwordhash, 'utf8', 'hex');\n  crypted += cipher.final('hex');\n  return { encrypted: crypted, pepperId: currentPepperId };\n};\n\n/* Encrypting a password.\n   Follows dropbox's pattern of hashing, bcrypting, then encrypting.\n   Seems safer: https://blogs.dropbox.com/tech/2016/09/how-dropbox-securely-stores-your-passwords/\n*/\nconst encryptPassword = function encryptPassword(rawPassword) {\n  return Promise.resolve(rawPassword)\n  .then(hashPassword)\n  .then(bcryptHash)\n  .then(aesHash);\n};\n\n/* Decrypts the encrypted bcrypt hash using aes256 using a pepper stored\n *   in the environment. Should use this only with the bcrypted, hashed password.\n */\nconst deAesHash = function deAesHash(passwordhash, pepperId) {\n  const pepper = process.env[pepperId];\n  if (!pepper) {\n    return new Error('Pepper not found.');\n  }\n  const algorithm = 'aes-256-ctr';\n  const decipher = crypto.createDecipher(algorithm, pepper);\n  let decrypted = decipher.update(passwordhash, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\n\n/* Compare passwords.\n * Because we are using hashing and encrypting, we have to do that before we compare.\n */\nconst passwordsMatch = function passwordsMatch(\n  candidatePassword,\n  encryptedPasswordHash,\n  pepperId,\n  ) {\n  // compare the submitted password to encrypted password in database.\n  const candidateHashed = hashPassword(candidatePassword);\n  const decryptedPass = deAesHash(encryptedPasswordHash, pepperId);\n  return compare(candidateHashed, decryptedPass);\n};\n\nexport { encryptPassword, deAesHash, hashPassword, bcryptHash, aesHash, passwordsMatch };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Account/passwordEncryption.js","module.exports = require(\"bcrypt\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bcrypt\"\n// module id = 14\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 15\n// module chunks = 0","import Base58 from 'base58';\nimport generator from 'generate-password';\n\n/* idier: identifier generator. Inspired by twitter's snowflake system\n * https://blog.twitter.com/2010/announcing-snowflake\n * We use the timestamp converted to seconds + a worker id from the environment +\n *   a sequence number (see below) + a single random number just in case...\n */\nconst idier = function idier() {\n  /* The sequence is stored on the global object. The sequence should be between 1-999 to keep\n   *   our total id number in the right space to be converted.\n   *   Note: There's probably an opportunity to use Redis or similar for the sequence.\n   */\n  let mySequence = 1;\n  const globalSeq = global.idierSequence;\n  if (globalSeq && globalSeq < 1000 && globalSeq > 0) {\n    mySequence = globalSeq;\n    global.idierSequence += 1;\n  } else {\n    global.idierSequence = mySequence + 1;\n  }\n\n  let workerId = process.env.IDIER_WORKER_ID;\n  if (!workerId) {\n    workerId = Math.floor(Math.random() * 10);\n  }\n  const timeStamp = Math.floor(Date.now() / 1000);\n  const randomnumber = Math.floor(Math.random() * 10);\n  const snowflake = `${timeStamp}${workerId}${mySequence}${randomnumber}`;\n  const snowflakeInt = parseInt(snowflake, 10);\n  return snowflakeInt;\n};\n\n/* toHumanId - transform a number into a base58 encoded string for use in human visible tokens.\n   Uses https://www.npmjs.com/package/base58\n  */\nconst toHumanId = function toHumanId(idNumber) {\n  const encoded = Base58.encode(idNumber);\n  return encoded;\n};\n\n/* toNumbericId - transform a humanId (base32 encoded) string to a number to use by the computer.\n  */\nconst toNumericId = function toNumericId(idString) {\n  const decoded = Base58.decode(idString);\n  return decoded;\n};\n\n\n/* Password generator\n * Creates a 12 digit password with letters and numbers.\n*/\nconst passGen = function passGen() {\n  const password = generator.generate({\n    length: 12,\n    numbers: true,\n  });\n  return password;\n};\n\nexport { idier, toHumanId, toNumericId, passGen };\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/helpers/idier.js","module.exports = require(\"base58\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"base58\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"generate-password\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"generate-password\"\n// module id = 18\n// module chunks = 0","import { isEmail, isEmpty } from 'validator';\nimport owasp from 'owasp-password-strength-test';\n\n/* Is the email valid? Uses the validator library to test.\n */\nconst appraiseEmail = function appraiseEmail(emailAddress) {\n  const messages = [];\n  if (isEmpty(emailAddress)) {\n    messages.push('Email address is required.');\n  }\n  if (!isEmpty(emailAddress) && !isEmail(emailAddress)) {\n    messages.push('Email address does not appear to be valid.');\n  }\n  return messages;\n};\n\n/* Test for the validity of the displayName.\n *  Currently only checks if it's empty.\n */\nconst appraiseDisplayName = function appraiseDisplayName(displayName) {\n  const messages = [];\n  if (isEmpty(displayName)) {\n    messages.push('Display name is required.');\n  }\n  return messages;\n};\n\n/* Tests a password.\n * Must be valid and pass the owasp validation tests.\n */\nconst appraisePassword = function appraisePassword(password) {\n  let messages = [];\n  if (isEmpty(password)) {\n    messages.push('Password is required.');\n  } else {\n    const owaspResults = owasp.test(password);\n    if (!owaspResults.strong) {\n      messages = messages.concat(owaspResults.errors);\n    }\n  }\n  return messages;\n};\n\nconst appraisePasswordErrors = {\n  minLength: 0,\n  maxLength: 1,\n  repeating: 2,\n  needLowercase: 3,\n  needUppercase: 4,\n  needNumber: 5,\n  needCharacter: 6,\n};\n\n/* A wrapper for awasp tests that returns this\n * {\n *   errors              : [],\n *   failedTests         : [],\n *   requiredTestErrors  : [],\n *   optionalTestErrors  : [],\n *   passedTests         : [ 0, 1, 2, 3, 4, 5, 6 ],\n *   isPassphrase        : false,\n *   strong              : true,\n *   optionalTestsPassed : 4\n * }\n */\nconst appraisePasswordExtra = function appraisePasswordExtra(password) {\n  return owasp.test(password);\n};\n\n/* Tests for the presense of an accountID.\n *  Only checks if it's empty.\n *  TODO: Check if the account actually exists.\n */\nconst appraiseAccountId = function appraiseAccountId(accountId) {\n  const messages = [];\n  if (isEmpty(accountId)) {\n    messages.push('AccountId is required.');\n  }\n  return messages;\n};\n\n/* Validates multiple options. Pass in an object with one of the following:\n * email: {string} validates an email (or empty}\n * displayName; {string} checks for empty\n * password: {string} validates a password\n * accountId: {string} validates the accountId\n * @returns: an object (see validator object below)\n */\nconst appraiseThese = function appraiseThese(what) {\n  const appraised = {\n    success: true,  // Did all tests pass\n    tested: [],  // Which tests where done? Check this to make sure things were passed in correctly.\n    errors: {},  // Error output from the sub-testers as objects.\n  };\n  if ('email' in what) {\n    appraised.tested.push('email');\n    const messages = appraiseEmail(what.email);\n    if (messages && messages.length > 0) {\n      appraised.success = false;\n      appraised.errors.email = messages;\n    }\n  }\n  if ('password' in what) {\n    appraised.tested.push('password');\n    const messages = appraisePassword(what.password);\n    if (messages && messages.length > 0) {\n      appraised.success = false;\n      appraised.errors.password = messages;\n    }\n  }\n  if ('displayName' in what) {\n    appraised.tested.push('displayName');\n    const messages = appraiseDisplayName(what.displayName);\n    if (messages && messages.length > 0) {\n      appraised.success = false;\n      appraised.errors.displayName = messages;\n    }\n  }\n  if ('accountId' in what) {\n    appraised.tested.push('accountId');\n    const messages = appraiseAccountId(what.accountId);\n    if (messages && messages.length > 0) {\n      appraised.success = false;\n      appraised.errors.accountId = messages;\n    }\n  }\n  return appraised;\n};\n\n/* Tests for the presense of a post message.\n *  Only checks if it's empty.\n *  Here for future functionality.\n */\nconst appraisePostMessage = function appraisePostMessage(postMessage) {\n  const messages = [];\n  if (!postMessage || isEmpty(postMessage)) {\n    messages.push('A message is required.');\n  }\n  return messages;\n};\n\n/* Tests for the presense of a post subject.\n *  Runs no checks.\n *  Here for future functionality.\n */\n/* eslint-disable no-unused-vars */\nconst appraisePostSubject = function appraisePostSubject(postSubject) {\n  return [];\n};\n/* eslint-enable no-unused-vars */\n\nexport {\n  appraiseThese,\n  appraiseEmail,\n  appraiseDisplayName,\n  appraisePassword,\n  appraisePasswordExtra,\n  appraisePasswordErrors,\n  appraiseAccountId,\n  appraisePostSubject,\n  appraisePostMessage,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/shared/helpers/appraise.js","module.exports = require(\"validator\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"validator\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"owasp-password-strength-test\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"owasp-password-strength-test\"\n// module id = 21\n// module chunks = 0","import './passportConfigure';\nimport ensureLoggedIn from './ensureLoggedIn';\nimport authenticationRoutes from './routes';\n\nexport { ensureLoggedIn, authenticationRoutes };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Authentication/index.js","import { Strategy } from 'passport-local';\nimport passport from 'passport';\nimport Account from '../Account/model';\n\n/* Configure the local strategy for use by Passport.\n *\n * The local strategy require a `verify` function which receives the credentials\n * (`username` and `password`) submitted by the user.  The function must verify\n * that the password is correct and then invoke `callback` with a user object, which\n * will be set at `req.user` in route handlers after authentication.\n */\npassport.use(new Strategy(\n  {\n    usernameField: 'email',\n    passwordField: 'password',\n  },\n  function snsLocalStrategy(email, password, callback) {\n    let foundAccount = null;\n    Account.findOneByEmail(email)\n      .then(function comparePass(theAccount) {\n        foundAccount = theAccount;\n        return theAccount.comparePassword(password);\n      })\n      .then(function returnAccount(passwordsMatched) {\n        if (!passwordsMatched) {\n          throw new Error('Could not verify account');\n        }\n        return foundAccount;\n      })\n      .then(function returnAccount(accountToReturn) {\n        callback(null, accountToReturn);\n      })\n      .catch(function catchAuthFailure(err) {\n        console.log(`Passport authentication failed: Unknown error: ${err}`);\n        return callback(null, false, { message: 'Could not authenticate account' });\n      });\n  }));\n\n\n/* Configure Passport authenticated session persistence.\n *\n * In order to restore authentication state across HTTP requests, Passport needs\n * to serialize users into and deserialize users out of the session.  The\n * typical implementation of this is as simple as supplying the user ID when\n * serializing, and querying the user record by ID from the database when\n * deserializing.\n */\npassport.serializeUser(function serializeAccount(account, callback) {\n  callback(null, account.accountId);\n});\n\npassport.deserializeUser(function deserializeAccount(accountId, callback) {\n  Account.findOneAccount(accountId)\n  .then(function determineAction(theAccount) {\n    return callback(null, theAccount);\n  })\n  .catch(function noFind(err) {\n    return callback(err);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Authentication/passportConfigure.js","module.exports = require(\"passport-local\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"passport-local\"\n// module id = 24\n// module chunks = 0","/* Based on here: https://github.com/jaredhanson/connect-ensure-login/blob/master/lib/ensureLoggedIn.js\n * Used under MIT license\n * I edited it to make it go along with my linter and easier for me to understand.\n * Original release notes:\n * Ensure that a user is logged in before proceeding to next route middleware.\n *\n * This middleware ensures that a user is logged in.  If a request is received\n * that is unauthenticated, the request will be redirected to a login page (by\n * default to `/login`).\n *\n * Additionally, `returnTo` will be be set in the session to the URL of the\n * current request.  After authentication, this value can be used to redirect\n * the user to the page that was originally requested.\n *\n * Options:\n *   - `redirectTo`   URL to redirect to for login, defaults to _/login_\n *   - `setReturnTo`  set redirectTo in session, defaults to _true_\n *\n * Examples:\n *\n *     app.get('/profile',\n *       ensureLoggedIn(),\n *       function(req, res) { ... });\n *\n *     app.get('/profile',\n *       ensureLoggedIn('/signin'),\n *       function(req, res) { ... });\n *\n *     app.get('/profile',\n *       ensureLoggedIn({ redirectTo: '/session/new', setReturnTo: false }),\n *       function(req, res) { ... });\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\nexport default function ensureLoggedIn(options) {\n  let unauthenticatedRedirectURL = '/login';\n  if (typeof options === 'string') {\n    unauthenticatedRedirectURL = options;\n  } else if (options && options.redirectTo && options.redirectTo.length > 0) {\n    unauthenticatedRedirectURL = options.redirectTo;\n  }\n  const allOptions = options || {};\n\n  const setReturnTo = (allOptions.setReturnTo === undefined) ? true : options.setReturnTo;\n\n  return function areWeAuthenticated(req, res, next) { // eslint-disable-line consistent-return\n    if (!req.isAuthenticated || !req.isAuthenticated()) {\n      if (setReturnTo && req.session) {\n        req.session.returnTo = req.originalUrl || req.url; // eslint-disable-line no-param-reassign\n      }\n      return res.redirect(unauthenticatedRedirectURL);\n    }\n    next();\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Authentication/ensureLoggedIn.js","import { Router } from 'express';\nimport passport from 'passport';\n\nconst routes = new Router();\n\nfunction signinUser(req, res, next) {\n  passport.authenticate('local', (err, user) => { // eslint-disable-line consistent-return\n    if (err || !user) {\n      res.statusMessage = 'Could not log in with that email and password combination.'; // eslint-disable-line no-param-reassign\n      res.status(422).end();\n    }\n    req.logIn(user, (error) => { // eslint-disable-line consistent-return\n      if (error) {\n        return next(error);\n      }\n      res.cookie('snssl', 'y', { httpOnly: false });\n\n      // you can send a json response instead of redirecting the user\n      res.status(201).json({\n        success: true,\n        message: 'Logged in',\n        account: user,\n      });\n    });\n  })(req, res, next);\n}\n\nroutes.route('/sessions')\n  .post(signinUser);\n\nroutes.route('/sessions')\n  .delete(function logThemOut(req, res) {\n    req.session.destroy();\n    req.logout();\n    res.clearCookie('snssl');\n    res.status(204).end();\n  });\n\n/* Checks if a user is currently authenticated.\n * Technically, checks the cookie.\n */\nroutes.route('/sessions')\n  .get(function isAuthenticated(req, res) {\n    if (!req.isAuthenticated || !req.isAuthenticated()) {\n      res.status(204).end();\n    }\n    res.status(403).end();\n  });\n\nexport default routes;\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Authentication/routes.js","import recipientRoutes from './routes';\nimport Recipient from './model';\nimport * as RecipientController from './controller';\n\nexport { recipientRoutes, Recipient, RecipientController };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Recipient/index.js","import { Router } from 'express';\nimport { getRecipientsEndpoint, addRecipientEndpoint, updateRecipientEndpoint, removeRecipientEndpoint } from './controller';\nimport { ensureLoggedIn } from '../Authentication';\n\nconst routes = new Router();\nroutes.get('/recipients', ensureLoggedIn(), getRecipientsEndpoint);\nroutes.post('/recipients', ensureLoggedIn(), addRecipientEndpoint);\nroutes.put('/recipients/:recipientId', ensureLoggedIn(), updateRecipientEndpoint);\nroutes.delete('/recipients/:recipientId', ensureLoggedIn(), removeRecipientEndpoint);\n\nexport default routes;\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Recipient/routes.js","import { Recipient, RecipientStatus } from './model';\n\n/* Returns either the current account's accountId or, if onBehalfOfId is passed in\n *  to the body, it will verify if the current account can act on behalf of the passed\n *  in id and return that.\n *  @param {object} req - the request object that has a user account attached\n *  @returns {string} accountId - the accountId to use in searches.\n */\nconst activeAccountId = function getAccount(req) {\n  const currentAccount = req.user;\n  const onBehalfOfId = req.body.onBehalfOfId;\n  if (onBehalfOfId && onBehalfOfId.length > 0) {\n    if (currentAccount && currentAccount.canActOnBehalfOf(onBehalfOfId)) {\n      return onBehalfOfId;\n    }\n  }\n  return req.user.accountId;\n};\n\n/* Get all of the recipients for the accountId.\n * Params needed in req.body:\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the search parameters.\n */\nconst getRecipientsEndpoint = (req, res) => { // eslint-disable-line consistent-return\n  const accountId = activeAccountId(req);\n  if (!accountId) {\n    return res.status(422).json({ success: false, message: 'No accountId provided' });\n  }\n  Recipient.findAllForId(accountId, false)\n    .then((recipients) => {\n      const cleanRecipients = recipients.map(function jsonify(recipient) {\n        return recipient.toJSON();\n      });\n      console.log('Found these recipients');\n      console.dir(recipients);\n      res.status(201).json({\n        success: true,\n        recipients: cleanRecipients,\n      });\n    })\n    .catch((err) => {\n      res.status(422).json({ success: false, message: err.message });\n    });\n};\n\n/* Adds an recipient to the Recipients database based on the fields passed in.\n * Params needed in req.body:\n *   @param {string} email - the email address\n *   @param {string} displayName - the displayName for the recipient.\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the accountId to search for.\n */\nconst addRecipientEndpoint = (req, res) => {\n  const { email, displayName } = req.body;\n  const accountId = activeAccountId(req);\n  const newRecipient = new Recipient({\n    email: email,\n    displayName: displayName,\n    ownerAccountId: accountId,\n  });\n  console.log('Heres the new recipient');\n  console.dir(newRecipient);\n  newRecipient.save()\n    .then((createdRecipient) => {\n      console.log('Created new recipient: ');\n      console.dir(createdRecipient);\n      console.dir(createdRecipient.toObject());\n      res.status(201).json({\n        success: true,\n        message: 'Successfully created recipient',\n        recipient: createdRecipient.toJSON(),\n      });\n    })\n    .catch((err) => {\n      console.log('Recipient creation error: ');\n      console.dir(err);\n      let errorMessage = 'Recipient could not be created.';\n      if (err.code === 11000) {\n        errorMessage = 'Recipient already exists';\n      } else if (err.message) {\n        errorMessage = err.message;\n      }\n      res.status(422).json({ success: false, messages: errorMessage });\n    });\n};\n\n/* Updates a recipient\n * Params needed in req.body:\n *   @param {string=} email (optional) - the email address to update.\n *   @param {string=} displayName (optional) - the displayName to update.\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param (number) recipientId - Will be pulled from req.params or req.body (body takes priority)\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the accountId to search for.\n */\nconst updateRecipientEndpoint = (req, res) => {\n  let recipientId = req.params.recipientId;\n  if (req.body.recipientId) {\n    recipientId = req.body.recipientId;\n  }\n  const { email, displayName, status } = req.body;\n  if (!recipientId) {\n    res.status(422).json({ success: false, messages: 'No recipientId provided.' });\n  }\n\n  const accountId = activeAccountId(req);\n  const updates = {};\n  if (email && email.length > 0) updates.email = email;\n  if (displayName && displayName.length > 0) updates.displayName = displayName;\n  if (status && status.length > 0) updates.status = status;\n\n  if (Object.keys(updates).length === 0) {\n    res.status(422).json({ success: false, messages: 'Nothing to update.' });\n  }\n  Recipient.update(recipientId, accountId, updates)\n    .then((updatedRecipient) => {\n      console.log('Updated recipient: ');\n      console.dir(updatedRecipient);\n      console.dir(updatedRecipient.toObject());\n      res.status(201).json({\n        success: true,\n        message: 'Successfully updated recipient',\n        recipient: updatedRecipient.toJSON(),\n      });\n    })\n    .catch((err) => {\n      console.log('Recipient update error: ');\n      console.dir(err);\n      let errorMessage = 'Recipient could not be updated.';\n      if (err.message) {\n        errorMessage = err.message;\n      }\n      res.status(422).json({ success: false, messages: errorMessage });\n    });\n};\n\n\n/* Removes a recipient (marks the status to 'removed')\n * Params needed in req.body:\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param (number) recipientId - Will be pulled from req.params or req.body (body takes priority)\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the accountId to search for.\n */\nconst removeRecipientEndpoint = (req, res) => {\n  let recipientId = req.params.recipientId;\n  if (req.body.recipientId) {\n    recipientId = req.body.recipientId;\n  }\n  if (!recipientId) {\n    res.status(422).json({ success: false, messages: 'No recipientId provided.' });\n  }\n\n  const accountId = activeAccountId(req);\n  Recipient.update(recipientId, accountId, { status: RecipientStatus.REMOVED })\n    .then((updatedRecipient) => {\n      console.log('Updated recipient: ');\n      console.dir(updatedRecipient);\n      console.dir(updatedRecipient.toObject());\n      res.status(201).json({\n        success: true,\n        message: 'Successfully removed recipient',\n      });\n    })\n    .catch((err) => {\n      console.log('Recipient removal error: ');\n      console.dir(err);\n      let errorMessage = 'Recipient could not be removed.';\n      if (err.message) {\n        errorMessage = err.message;\n      }\n      res.status(422).json({ success: false, messages: errorMessage });\n    });\n};\n\n\nexport {\n  getRecipientsEndpoint,\n  addRecipientEndpoint,\n  updateRecipientEndpoint,\n  removeRecipientEndpoint,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Recipient/controller.js","import mongoose, { Schema } from 'mongoose';\nimport { appraiseEmail, appraiseDisplayName } from '../../../shared/helpers/appraise';\nimport { idier } from '../../../shared/helpers/idier';\n\nconst RecipientStatus = {\n  VALIDATING: 'validating',\n  ACTIVE: 'active',\n  REMOVED: 'removed',\n  BOUNCING: 'bouncing',\n  UNSUBSCRIBED: 'unsubscribed',\n};\n\n/* Recipient schema represents all recipients for an account.\n */\nconst RecipientSchema = new Schema({\n  status: {\n    type: Schema.Types.String,\n    default: RecipientStatus.ACTIVE,\n    enum: [\n      RecipientStatus.VALIDATING,\n      RecipientStatus.ACTIVE,\n      RecipientStatus.REMOVED,\n      RecipientStatus.BOUNCING,\n      RecipientStatus.UNSUBSCRIBED,\n    ],\n  },\n  recipientId: {\n    type: Schema.Types.Number,\n    unique: true,\n    required: true,\n  },\n  ownerAccountId: {\n    type: Schema.Types.Number,\n    required: true,\n    index: true,\n  },\n  email: {\n    type: String,\n    trim: true,\n  },\n  phoneNumber: {\n    type: String,\n  },\n  phoneType: {\n    type: String,\n  },\n  displayName: {\n    type: String,\n    trim: true,\n  },\n  dateCreated: {\n    type: Date,\n    default: Date.now,\n  },\n  dateUpdated: {\n    type: Date,\n    default: Date.now,\n  },\n  dateRecipientValidated: {\n    type: Date,\n  },\n  dateUnsubscribed: {\n    type: Date,\n  },\n  unsubscriptionReason: {\n    type: String,\n  },\n  dateRemoved: {\n    type: Date,\n  },\n});\n\n/* If it's a new recipient, create an recipientId for it. */\nRecipientSchema.pre('validate', function preValidateRecipient(next) {\n  console.log('Called pre save recipient');\n  if (!this.recipientId) {\n    this.recipientId = idier();\n  }\n  next();\n});\n\n/* Update the dateUpdated field on save. */\nRecipientSchema.pre('save', true, function updateRecipientDate(next, done) {\n  this.dateUpdated = new Date();\n  next();\n  done();\n});\n\n/* Does the pre-save validations.\n * Why here instead of on each individual field? Allows us to return multiple errors at once.\n */\nRecipientSchema.pre('save', true, function preRecipientSaveValidations(next, done) {\n  const errorMessages = [];\n  const emailAppraisal = appraiseEmail(this.email);\n  if (emailAppraisal.length > 0) {\n    this.invalidate('email', emailAppraisal.join(', '));\n    errorMessages.push(emailAppraisal.join(', '));\n  }\n\n  const displayNameAppraisal = appraiseDisplayName(this.displayName);\n  if (displayNameAppraisal.length > 0) {\n    this.invalidate('displayName', displayNameAppraisal.join(', '));\n    errorMessages.push(displayNameAppraisal.join(' '));\n  }\n  if (errorMessages.length > 0) {\n    done(new Error(errorMessages.join(' ')));\n  }\n  next();\n  done();\n});\n\n/* Remove password and pepper from exported json && object\n * Based on: http://ksloan.net/tips-for-using-mongoose-schemas-with-express-mongo-express-node-stack/\n */\nRecipientSchema.set('toJSON', {\n  transform: function transformJSON(doc, objRepresentation) {\n    return {\n      recipientId: objRepresentation.recipientId,\n      email: objRepresentation.email,\n      displayName: objRepresentation.displayName,\n      dateCreated: objRepresentation.dateCreated,\n      dateUnsubscribed: objRepresentation.dateUnsubscribed,\n      status: objRepresentation.status,\n    };\n  },\n});\n\n/* Find a recipient by an recipientId\n * @param {number} recipientId - the recipient id\n * @returns {promise} - a promise to find something\n */\nRecipientSchema.statics.findOneRecipient = function findRecipientById(recipientId) {\n  return this.findOne({ recipientId: recipientId }).exec();\n};\n\n/* Find a recipient by an recipientId and update the appropriate fields.\n * @param {number} recipientId - the recipient id\n * @param {object} fieldsToUpdate - the fields and their values to update to.\n * @returns {promise} - a promise to find something\n * @note: We do it this way instead of findOneAndUpdate because update and valdiation hooks are\n *   not called on findOneAndUpdate.\n */\nRecipientSchema.statics.update = function findARecipientById(recipientId, ownerId, fieldsToUpdate) {\n  return this.findOne({ recipientId: recipientId, ownerAccountId: ownerId }).exec()\n    .then((foundItem) => {\n      const foundRecipient = foundItem;\n      const fieldsToUpdateKeys = Object.keys(fieldsToUpdate);\n      fieldsToUpdateKeys.forEach(function modifyItem(key) {\n        foundRecipient[key] = fieldsToUpdate[key];\n      });\n      return foundRecipient.save();\n    });\n};\n\n/* Find a recipient by an email address\n * @param {string} email - the associated email address\n * @returns {promise} - a promise to find something\n */\nRecipientSchema.statics.findOneByEmail = function findRecipientByEmail(email) {\n  return this.findOne({ email: email }).exec();\n};\n\n/* Find all recipients for an accountId\n * @param {string} accountId - the accountId to search for\n * @returns {promise} - a promise to find something\n */\nRecipientSchema.statics.findAllForId = function findRecipients(accountId, lean = true) {\n  if (lean) {\n    return this.find({ ownerAccountId: accountId }).lean().exec();\n  }\n  return this.find({ ownerAccountId: accountId }).exec();\n};\n\n/* Determine total number of recipients for account\n * @param {number} - accountId\n */\nRecipientSchema.statics.totalForAccountId = function countRecipients(accountId) {\n  return this.count({ ownerAccountId: accountId }).exec();\n};\n\n/* Compile the schema into a model\n * http://mongoosejs.com/docs/models.html\n */\nconst Recipient = mongoose.model('Recipient', RecipientSchema);\n\nexport { Recipient, RecipientStatus };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Recipient/model.js","import postRoutes from './routes';\nimport Post from './model';\nimport * as PostController from './controller';\n\nexport { postRoutes, Post, PostController };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Post/index.js","import { Router } from 'express';\nimport {\n  getPostsEndpoint,\n  addPostEndpoint,\n  updatePostEndpoint,\n  removePostEndpoint,\n} from './controller';\nimport { ensureLoggedIn } from '../Authentication';\n\nconst routes = new Router();\nroutes.get('/posts', ensureLoggedIn(), getPostsEndpoint);\nroutes.post('/posts', ensureLoggedIn(), addPostEndpoint);\nroutes.put('/posts/:postId', ensureLoggedIn(), updatePostEndpoint);\nroutes.delete('/posts/:postId', ensureLoggedIn(), removePostEndpoint);\n\nexport default routes;\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Post/routes.js","import { Post, PostStatus } from './model';\n\n/* Returns either the current account's accountId or, if onBehalfOfId is passed in\n *  to the body, it will verify if the current account can act on behalf of the passed\n *  in id and return that.\n *  @param {object} req - the request object that has a user account attached\n *  @returns {string} accountId - the accountId to use in searches.\n *   TODO: need to move it to it's own module since we're duplicating it in every controller.\n */\nconst activeAccountId = function getAccount(req) {\n  const currentAccount = req.user;\n  const onBehalfOfId = req.body.onBehalfOfId;\n  if (onBehalfOfId && onBehalfOfId.length > 0) {\n    if (currentAccount && currentAccount.canActOnBehalfOf(onBehalfOfId)) {\n      return onBehalfOfId;\n    }\n  }\n  if (req.user && req.user.accountId) {\n    return req.user.accountId;\n  }\n  return null;\n};\n\n/* Get all of the posts for the accountId.\n * Params needed in req.body:\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the search parameters.\n */\nconst getPostsEndpoint = (req, res) => { // eslint-disable-line consistent-return\n  const accountId = activeAccountId(req);\n  if (!accountId) {\n    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n    res.status(422).end();\n  }\n  Post.findAllForId(accountId, false)\n    .then((items) => {\n      const cleanedItems = items.map(function jsonify(mappedItem) {\n        return mappedItem.toJSON();\n      });\n      res.status(200).json({\n        success: true,\n        posts: cleanedItems,\n      });\n    })\n    .catch((err) => {\n      res.statusMessage = err.message; // eslint-disable-line no-param-reassign\n      res.status(404).end();\n    });\n};\n\n/* Adds a post to the Post database based on the fields passed in.\n * Params needed in req.body:\n *   @param {string} message - the main message body\n *   @param {string=} subject (optional) - subject of the post.\n *   @param {array[number]} mediaIds - the mediaIds associated with this post.\n *   @param {string=} status (optional) - Must be one of PostStatus (see Post model).\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the accountId to search for.\n */\nconst addPostEndpoint = (req, res) => {\n  const accountId = activeAccountId(req);\n  if (!accountId) {\n    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n    res.status(422).end();\n  }\n  const { message, subject, mediaIds, status } = req.body;\n  const newItem = new Post({\n    message: message,\n    subject: subject,\n    mediaIds: mediaIds,\n    status: status,\n    ownerAccountId: accountId,\n  });\n  newItem.save()\n    .then((createdItem) => {\n      const cleanedPost = createdItem.toJSON();\n      res.status(201).json({\n        success: true,\n        message: 'Successfully created post',\n        recipient: cleanedPost,\n      });\n    })\n    .catch((err) => {\n      let errorMessage = 'Post could not be created.';\n      if (err.code === 11000) {\n        errorMessage = 'Post already exists';\n      } else if (err.message) {\n        errorMessage = err.message;\n      }\n      res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n      res.status(422).end();\n    });\n};\n\n/* Updates a post\n *   @param {string} message - the main message body\n *   @param {string=} subject (optional) - subject of the post.\n *   @param {array[number]} mediaIds - the mediaIds associated with this post.\n *   @param {string=} status (optional) - Must be one of PostStatus (see Post model).\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param (number) postId - Will be pulled from req.params or req.body (body takes priority)\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the accountId to search for.\n */\nconst updatePostEndpoint = (req, res) => {\n  const accountId = activeAccountId(req);\n  if (!accountId) {\n    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n    res.status(422).end();\n  }\n  let itemId = req.params.postId;\n  if (req.body.postId) {\n    itemId = req.body.postId;\n  }\n  if (!itemId) {\n    res.status(422).json({ success: false, messages: 'No PostId provided.' });\n  }\n  const { message, subject, mediaIds, status } = req.body;\n  const updates = {};\n  if (message && message.length > 0) updates.message = message;\n  if (subject && subject.length > 0) updates.subject = subject;\n  if (mediaIds && mediaIds.length > 0) updates.mediaIds = mediaIds;\n  if (status && status.length > 0) updates.status = status;\n\n  if (Object.keys(updates).length === 0) {\n    res.status(422).json({ success: false, messages: 'Nothing to update.' });\n  }\n  Post.update(itemId, accountId, updates)\n    .then((updatedItem) => {\n      res.status(200).json({\n        success: true,\n        message: 'Successfully updated post',\n        post: updatedItem.toJSON(),\n      });\n    })\n    .catch((err) => {\n      let errorMessage = 'Post could not be updated.';\n      if (err.message) {\n        errorMessage = err.message;\n      }\n      res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n      res.status(422).end();\n    });\n};\n\n\n/* Removes a post (marks the status to 'removed')\n * Params needed in req.body:\n *   @param (number=} onBehalfOfId - (optional) The accountId to act on behalf of if current account\n *      can act on behalf of it.\n *  @param (number) postId - Will be pulled from req.params or req.body (body takes priority)\n *  @param {number} accountId - Will be pulled from req.user.\n *  Uses activeAccountId() to get the accountId to search for.\n */\nconst removePostEndpoint = (req, res) => {\n  const accountId = activeAccountId(req);\n  if (!accountId) {\n    res.statusMessage = 'No accountId provided'; // eslint-disable-line no-param-reassign\n    res.status(422).end();\n  }\n  let itemId = req.params.postId;\n  if (req.body.postId) {\n    itemId = req.body.postId;\n  }\n  if (!itemId) {\n    res.statusMessage = 'No postId provided.'; // eslint-disable-line no-param-reassign\n    res.status(422).end();\n  }\n  Post.update(itemId, accountId, { status: PostStatus.REMOVED })\n    .then(() => {\n      res.status(204).end();\n    })\n    .catch((err) => {\n      let errorMessage = 'Post could not be removed.';\n      if (err.message) {\n        errorMessage = err.message;\n      }\n      res.statusMessage = errorMessage; // eslint-disable-line no-param-reassign\n      res.status(422).end();\n    });\n};\n\n\nexport {\n  getPostsEndpoint,\n  addPostEndpoint,\n  updatePostEndpoint,\n  removePostEndpoint,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Post/controller.js","import mongoose, { Schema } from 'mongoose';\nimport { idier } from '../../../shared/helpers/idier';\n\n/* The maximum we can return from a search */\nconst MAX_RETURN_LIMIT = 100;\n\n/* Enum for the post.status field */\nconst PostStatus = {\n  DRAFT: 'draft',\n  POSTED: 'posted',\n  REMOVED: 'removed',\n};\n\n/* Post schema represents all posts.\n * https://developers.facebook.com/docs/graph-api/reference/v2.8/post\n */\nconst PostSchema = new Schema({\n  status: {\n    type: Schema.Types.String,\n    default: PostStatus.POSTED,\n    enum: [\n      PostStatus.DRAFT,\n      PostStatus.POSTED,\n      PostStatus.REMOVED,\n    ],\n  },\n  postId: {\n    type: Schema.Types.Number,\n    unique: true,\n    required: true,\n  },\n  message: {\n    type: Schema.Types.String,\n    required: true,\n  },\n  subject: {\n    type: Schema.Types.String,\n  },\n  mediaIds: {\n    type: Schema.Types.Array,\n  },\n  ownerAccountId: {\n    type: Schema.Types.Number,\n    required: true,\n    index: true,\n  },\n  dateCreated: {\n    type: Date,\n    default: Date.now,\n  },\n  dateUpdated: {\n    type: Date,\n    default: Date.now,\n  },\n});\n\n/* If it's a new post, create an postId for it. */\nPostSchema.pre('validate', function preValidatePost(next) {\n  if (!this.postId) {\n    this.postId = idier();\n  }\n  next();\n});\n\n/* Update the dateUpdated field on save. */\nPostSchema.pre('save', true, function updatePostDate(next, done) {\n  this.dateUpdated = new Date();\n  next();\n  done();\n});\n\n/*\n * Based on: http://ksloan.net/tips-for-using-mongoose-schemas-with-express-mongo-express-node-stack/\n */\nPostSchema.set('toJSON', {\n  transform: function transformJSON(doc, objRepresentation) {\n    return {\n      postId: objRepresentation.postId,\n      message: objRepresentation.message,\n      subject: objRepresentation.subject,\n      mediaIds: objRepresentation.mediaIds,\n      ownerAccountId: objRepresentation.ownerAccountId,\n      dateCreated: objRepresentation.dateCreated,\n      dateUpdated: objRepresentation.dateUpdated,\n      status: objRepresentation.status,\n    };\n  },\n});\n\n/* Find a post by an postId\n * @param {number} postId - the post identifier\n * @returns {promise} - a promise to find something\n */\nPostSchema.statics.findOnePost = function findPostById(postId) {\n  return this.findOne({ postId: postId }).exec();\n};\n\n/* Find a post by an postId and update the appropriate fields.\n * @param {number} recipientId - the recipient id\n * @param {number} ownerId - the owner id\n * @param {object} fieldsToUpdate - the fields and their values to update to.\n * @returns {promise} - a promise to find and update something\n * @note: We do it this way instead of findOneAndUpdate because update and valdiation hooks are\n *   not called on findOneAndUpdate.\n */\nPostSchema.statics.update = function updatePostById(postId, ownerId, fieldsToUpdate) {\n  return this.findOne({ postId: postId, ownerAccountId: ownerId }).exec()\n    .then((foundItem) => {\n      const foundPost = foundItem;\n      const fieldsToUpdateKeys = Object.keys(fieldsToUpdate);\n      fieldsToUpdateKeys.forEach(function modifyItem(key) {\n        foundPost[key] = fieldsToUpdate[key];\n      });\n      return foundPost.save();\n    });\n};\n\n/* Find all posts for an accountId\n * @param {string} accountId - the accountId to search for\n * @param {number} limit - the number to find.\n * @param {number} beforeId - the identifier to sort before. If this is passed, limit is used.\n * @returns {promise} - a promise to find something\n */\nPostSchema.statics.findAllForId = function allPosts(accountId, limit = 20, beforeId) {\n  let limiter = limit;\n  if (limiter > MAX_RETURN_LIMIT) limiter = MAX_RETURN_LIMIT;\n\n  if (beforeId) {\n    return this.find({ ownerAccountId: accountId, postId: { $lte: beforeId } })\n      .limit(limiter)\n      .sort({ postId: -1 })\n      .exec();\n  }\n  return this.find({ ownerAccountId: accountId }).limit(limiter).sort({ postId: -1 }).exec();\n};\n\n/* Determine total number of posts for account\n * @param {number} - accountId\n */\nPostSchema.statics.totalForAccountId = function countPosts(accountId) {\n  return this.count({ ownerAccountId: accountId }).exec();\n};\n\n/* Compile the schema into a model\n * http://mongoosejs.com/docs/models.html\n */\nconst Post = mongoose.model('Post', PostSchema);\n\nexport { Post, PostStatus };\n\n\n\n// WEBPACK FOOTER //\n// ./src/apiserver/modules/Post/model.js","import dotenv from 'dotenv';\nimport requireEnv from 'require-environment-variables';\n\n/* 'As early as possible in your application, require and configure dotenv.'\n *   - https://www.npmjs.com/package/dotenv\n *\n * However, we aren't going to load these in production as it could lead to sloppy deploys.\n */\nif (process.env.NODE_ENV && process.env.NODE_ENV !== 'production') {\n  dotenv.load();\n} else {\n  dotenv.load();\n}\n\n/* If any of the environment variables(process.env.REDIS_URL) don't exist,\n *   the process exits with code 400.\n * https://github.com/bjoshuanoah/require-environment-variables\n */\nrequireEnv([\n  'REDIS_URL',\n  'MONGODB_URI',\n  'API_SERVER_PORT',\n  'MAIN_SERVER_PORT',\n  'ACCOUNT_PEPPER_1',\n  'ACCOUNT_ENCRYPT_CURRENT_PEPPER',\n  'IDIER_WORKER_ID',\n]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/config/environment.js","module.exports = require(\"dotenv\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"dotenv\"\n// module id = 36\n// module chunks = 0","module.exports = require(\"require-environment-variables\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"require-environment-variables\"\n// module id = 37\n// module chunks = 0","import mongoose from 'mongoose';\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nconst options = {\n  server: { socketOptions: { keepAlive: 300000, connectTimeoutMS: 30000 } },\n  replset: { socketOptions: { keepAlive: 300000, connectTimeoutMS: 30000 } },\n};\n\nmongoose.Promise = global.Promise;\n\n/* Connect to mongo */\nmongoose.connect(MONGODB_URI, options);\nmongoose.connection\n  .once('open', () => console.log(`Connected to MongoDb: running on ${MONGODB_URI}`))\n  .on('error', err => console.warn('Warning', err));\n\nexport default mongoose;\n\n\n\n// WEBPACK FOOTER //\n// ./src/config/mongoConnect.js","import redis from 'redis';\n\nconst REDIS_URL = process.env.REDIS_URL;\n\n/* Connect to redis */\nconst redisClient = redis.createClient(REDIS_URL);\n\nredisClient.on('error', function redisErrorReport(err) {\n  console.log(`Redis connection error ${err}`);\n});\n\nexport default redisClient;\n\n\n\n// WEBPACK FOOTER //\n// ./src/config/redisConnect.js","module.exports = require(\"redis\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"redis\"\n// module id = 40\n// module chunks = 0","module.exports = require(\"connect-redis\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"connect-redis\"\n// module id = 41\n// module chunks = 0"],"sourceRoot":""}